<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–‡å­—å›¾ç‰‡ç”Ÿæˆå™¨</title>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Google Fonts Import for UI and Handwriting Fonts */
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Smiley+Sans&family=LXGW+WenKai+Lite&family=Ma+Shan+Zheng&family=Liu+Jian+Mao+Cao&family=Long+Cang&family=Noto+Sans+SC:wght@300;400;500;700&family=Noto+Serif+SC:wght@300;400;500;700&family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            /* ä½¿ç”¨Interä½œä¸ºUIç•Œé¢çš„é»˜è®¤å­—ä½“ */
        }

        /* Custom Handwriting Font Styles */
        .font-zcool-kuaile {
            font-family: 'ZCOOL KuaiLe', cursive;
        }

        .font-smiley-sans {
            font-family: 'Smiley Sans', sans-serif;
        }

        .font-lxgw-wenkai {
            font-family: 'LXGW WenKai Lite', cursive;
            /* Using Lite version for broader compatibility */
        }

        .font-ma-shan-zheng {
            font-family: 'Ma Shan Zheng', cursive;
        }

        .font-liu-jian-mao-cao {
            font-family: 'Liu Jian Mao Cao', cursive;
        }

        .font-long-cang {
            font-family: 'Long Cang', cursive;
        }

        /* New Noto Sans SC Styles */
        .font-noto-sans-sc {
            font-family: 'Noto Sans SC', sans-serif;
        }

        /* New Noto Serif SC Styles */
        .font-noto-serif-sc {
            font-family: 'Noto Serif SC', serif;
        }

        /* Hide Canvas, only show Image */
        #outputCanvas {
            display: none;
        }

        /* Custom Slider Styles */
        input[type='range']::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            /* purple-500 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
            /* purple-500 with opacity */
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }

        input[type='range']::-webkit-slider-thumb:hover {
            background: #7c3aed;
            /* purple-600 */
        }

        input[type='range']::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }

        input[type='range']::-moz-range-thumb:hover {
            background: #7c3aed;
        }
    </style>
</head>

<body
    class="bg-gradient-to-br from-purple-100 via-pink-100 to-blue-200 min-h-screen flex items-center justify-center p-6 text-gray-800">

    <div
        class="bg-white p-10 rounded-3xl shadow-2xl max-w-5xl w-full border border-gray-100 transform transition-all duration-300 hover:scale-[1.005]">
        <h1
            class="text-5xl font-extrabold text-center text-purple-700 mb-10 tracking-tight flex items-center justify-center space-x-3">
            <svg class="w-10 h-10 text-pink-500" fill="currentColor" viewBox="0 0 20 20"
                xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd"
                    d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828zM4 12a2 2 0 012-2h.01a.75.75 0 100-1.5H6a3.5 3.5 0 00-3.5 3.5v1.5a.75.75 0 001.5 0V12zM15 15a.75.75 0 00-.75.75v1.5a.75.75 0 01-.75.75H4a2 2 0 01-2-2v-1.5a.75.75 0 00-1.5 0v1.5a3.5 3.5 0 003.5 3.5h9.5a3.5 3.5 0 003.5-3.5v-1.5a.75.75 0 00-1.5 0V15z"
                    clip-rule="evenodd"></path>
            </svg>
            <span>æ–‡å­—å›¾ç‰‡ç”Ÿæˆå™¨</span>
        </h1>

        <div class="grid md:grid-cols-2 gap-10">
            <!-- è®¾ç½®è¡¨å• -->
            <div class="space-y-7">
                <div>
                    <label for="inputText" class="block text-lg font-semibold text-gray-700 mb-2">è¾“å…¥æ–‡å­—:</label>
                    <textarea id="inputText"
                        class="w-full p-4 border border-gray-300 rounded-xl focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base h-40 resize-y shadow-sm hover:shadow-md"
                        placeholder="åœ¨è¿™é‡Œè¾“å…¥ä½ æƒ³è¦ç”Ÿæˆçš„æ–‡å­—...ï¼ˆå›è½¦å’Œç©ºæ ¼ä¼šè¢«ä¿ç•™ï¼‰"></textarea>
                </div>

                <div>
                    <label for="fontSelect" class="block text-lg font-semibold text-gray-700 mb-2">é€‰æ‹©å­—ä½“:</label>
                    <select id="fontSelect"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="LXGW WenKai Lite">éœé¹œæ–‡æ¥· (LXGW WenKai Lite)</option>
                        <option value="ZCOOL KuaiLe">ç«™é…·å¿«ä¹ä½“ (ZCOOL KuaiLe)</option>
                        <option value="Smiley Sans">å¾—æ„é»‘ (Smiley Sans)</option>
                        <option value="Ma Shan Zheng">é©¬å–„æ”¿ (Ma Shan Zheng)</option>
                        <option value="Liu Jian Mao Cao">åˆ˜æ±Ÿæ¯›è‰ (Liu Jian Mao Cao)</option>
                        <option value="Long Cang">é¾™è—ä½“ (Long Cang)</option>
                        <option value="Noto Sans SC">æ€æºé»‘ä½“ (Noto Sans SC)</option>
                        <option value="Noto Serif SC">æ€æºå®‹ä½“ (Noto Serif SC)</option>
                        <option value="CustomUploadedFont">è‡ªå®šä¹‰ä¸Šä¼ å­—ä½“ (Custom Uploaded Font)</option>
                    </select>
                </div>

                <!-- Custom Font Upload Section -->
                <div id="customFontUploadContainer" class="hidden space-y-2">
                    <label for="customFontUploadInput" class="block text-lg font-semibold text-gray-700 mb-2">ä¸Šä¼ å­—ä½“æ–‡ä»¶
                        (.ttf, .otf, .woff, .woff2):</label>
                    <input type="file" id="customFontUploadInput" accept=".ttf,.otf,.woff,.woff2"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md cursor-pointer">
                    <span id="fontUploadStatus" class="block text-sm text-gray-600 mt-1">è¯·ä¸Šä¼ å­—ä½“æ–‡ä»¶ï¼Œå¦‚ TTF, OTF, WOFF, WOFF2
                        æ ¼å¼ã€‚</span>
                </div>


                <div>
                    <label for="backgroundSelect" class="block text-lg font-semibold text-gray-700 mb-2">é€‰æ‹©èƒŒæ™¯:</label>
                    <select id="backgroundSelect"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="notebook">ç¬”è®°æœ¬</option>
                        <option value="parchment-texture">ç¾Šçš®çº¸çº¹ç†</option>
                        <option value="vintage-paper">å¤å¤çº¸å¼ </option>
                        <option value="white">çº¯ç™½</option>
                        <option value="solid">çº¯è‰²</option>
                        <option value="gradient">æ¸å˜è‰²</option>
                        <option value="custom">è‡ªå®šä¹‰å›¾ç‰‡</option>
                    </select>
                </div>

                <!-- Solid Color Picker Container -->
                <div id="solidColorContainer" class="hidden space-y-2">
                    <label for="solidColorPicker" class="block text-lg font-semibold text-gray-700 mb-2">é€‰æ‹©çº¯è‰²:</label>
                    <input type="color" id="solidColorPicker" value="#F0F0F0"
                        class="w-full h-12 border border-gray-300 rounded-xl cursor-pointer focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out shadow-sm hover:shadow-md">
                </div>

                <!-- Gradient Color Picker Container -->
                <div id="gradientColorContainer" class="hidden space-y-2">
                    <label class="block text-lg font-semibold text-gray-700 mb-2">æ¸å˜è‰²è®¾ç½®:</label>
                    <div class="flex items-center space-x-4">
                        <div class="flex-1">
                            <label for="gradientStartColor"
                                class="block text-sm font-medium text-gray-700 mb-1">èµ·å§‹é¢œè‰²:</label>
                            <input type="color" id="gradientStartColor" value="#ADD8E6"
                                class="w-full h-10 border border-gray-300 rounded-lg cursor-pointer focus:ring-2 focus:ring-purple-400">
                        </div>
                        <div class="flex-1">
                            <label for="gradientEndColor"
                                class="block text-sm font-medium text-gray-700 mb-1">ç»“æŸé¢œè‰²:</label>
                            <input type="color" id="gradientEndColor" value="#E6B0AD"
                                class="w-full h-10 border border-gray-300 rounded-lg cursor-pointer focus:ring-2 focus:ring-purple-400">
                        </div>
                    </div>
                    <!-- New: Gradient Angle Control -->
                    <div class="mt-4">
                        <label for="gradientAngleInput" class="block text-sm font-medium text-gray-700 mb-1">æ¸å˜è§’åº¦
                            (åº¦):</label>
                        <input type="range" id="gradientAngleInput" min="0" max="360" value="180"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="gradientAngleValue" class="block text-sm text-gray-600 mt-2 text-right">180Â°</span>
                    </div>
                </div>

                <!-- è‡ªå®šä¹‰èƒŒæ™¯ä¸Šä¼  -->
                <div id="customBgUploadContainer" class="hidden">
                    <label for="customBgUpload"
                        class="block text-lg font-semibold text-gray-700 mb-2">ä¸Šä¼ è‡ªå®šä¹‰èƒŒæ™¯å›¾ç‰‡:</label>
                    <input type="file" id="customBgUpload" accept="image/*"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md cursor-pointer">
                    <span class="block text-sm text-gray-600 mt-1">æ”¯æŒ JPG, PNG ç­‰æ ¼å¼ã€‚å›¾ç‰‡å°†è‡ªåŠ¨ç¼©æ”¾ä»¥è¦†ç›–æ•´ä¸ªèƒŒæ™¯ã€‚</span>
                </div>


                <div>
                    <label for="textColor" class="block text-lg font-semibold text-gray-700 mb-2">æ–‡å­—é¢œè‰²:</label>
                    <input type="color" id="textColor" value="#333333"
                        class="w-full h-12 border border-gray-300 rounded-xl cursor-pointer focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out shadow-sm hover:shadow-md">
                </div>

                <div>
                    <label for="fontSize" class="block text-lg font-semibold text-gray-700 mb-2">å­—ä½“å¤§å°:</label>
                    <input type="range" id="fontSize" min="20" max="80" value="40"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="fontSizeValue" class="block text-sm text-gray-600 mt-2 text-right">40px</span>
                </div>

                <!-- å­—é—´è·å’Œè¡Œé—´è· -->
                <div>
                    <label for="charSpacing" class="block text-lg font-semibold text-gray-700 mb-2">å­—é—´è·:</label>
                    <input type="range" id="charSpacing" min="-10" max="20" value="0"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="charSpacingValue" class="block text-sm text-gray-600 mt-2 text-right">0px</span>
                    <span class="block text-sm text-gray-600 mt-1">è°ƒæ•´å­—ç¬¦ä¹‹é—´çš„é¢å¤–ç©ºé—´ã€‚</span>
                </div>

                <div>
                    <label for="lineSpacingFactor" class="block text-lg font-semibold text-gray-700 mb-2">è¡Œé—´è·:</label>
                    <input type="range" id="lineSpacingFactor" min="80" max="200" value="100"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="lineSpacingFactorValue" class="block text-sm text-gray-600 mt-2 text-right">100%</span>
                    <span class="block text-sm text-gray-600 mt-1">è°ƒæ•´è¡Œä¸è¡Œä¹‹é—´çš„é¢å¤–ç©ºé—´ (100% ä¸ºé»˜è®¤)ã€‚</span>
                </div>


                <!-- æ–‡å­—ä½ç½®è®¾ç½® -->
                <div>
                    <label for="textAlignment" class="block text-lg font-semibold text-gray-700 mb-2">æ–‡å­—ä½ç½® (æ°´å¹³):</label>
                    <select id="textAlignment"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="left">å±…å·¦</option>
                        <option value="center">å±…ä¸­</option>
                        <option value="right">å±…å³</option>
                    </select>
                </div>

                <div>
                    <label for="topOffset" class="block text-lg font-semibold text-gray-700 mb-2">è·ç¦»é¡¶éƒ¨ (%):</label>
                    <input type="range" id="topOffset" min="0" max="50" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="topOffsetValue" class="block text-sm text-gray-600 mt-2 text-right">5%</span>
                    <span class="block text-sm text-gray-600 mt-1">è®¾ç½®æ–‡å­—å†…å®¹å—è·ç¦»å›¾ç‰‡é¡¶éƒ¨çš„ç™¾åˆ†æ¯”ã€‚</span>
                </div>

                <!-- éšæœºæŠ–åŠ¨å¼ºåº¦ -->
                <div>
                    <label for="randomnessIntensity"
                        class="block text-lg font-semibold text-gray-700 mb-2">éšæœºæŠ–åŠ¨å¼ºåº¦:</label>
                    <input type="range" id="randomnessIntensity" min="0" max="25" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="randomnessIntensityValue" class="block text-sm text-gray-600 mt-2 text-right">5</span>
                    <span class="block text-sm text-gray-600 mt-1">å¢åŠ æ–‡å­—çš„éšæœºåç§»ï¼Œæ¨¡æ‹Ÿæ‰‹å†™ä¸è§„åˆ™æ„Ÿï¼ˆ0ä¸ºæ— æŠ–åŠ¨ï¼‰ã€‚</span>
                </div>

                <!-- éšæœºå€¾æ–œè§’åº¦ -->
                <div>
                    <label for="lineSkewAngle" class="block text-lg font-semibold text-gray-700 mb-2">éšæœºå€¾æ–œè§’åº¦
                        (åº¦):</label>
                    <input type="range" id="lineSkewAngle" min="0" max="15" value="0"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="lineSkewAngleValue" class="block text-sm text-gray-600 mt-2 text-right">0Â°</span>
                    <span class="block text-sm text-gray-600 mt-1">è®¾ç½®æ¯è¡Œ/å­—ç¬¦çš„éšæœºå€¾æ–œèŒƒå›´ï¼ˆ0ä¸ºæ— å€¾æ–œï¼‰ã€‚</span>
                </div>

                <!-- å‚ç›´ä¹¦å†™æ¨¡å¼ -->
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="verticalWriting"
                        class="h-5 w-5 text-purple-600 rounded focus:ring-purple-500 cursor-pointer">
                    <label for="verticalWriting" class="text-lg font-semibold text-gray-700">å‚ç›´ä¹¦å†™æ¨¡å¼</label>
                </div>

                <!-- å‚ç›´ä¹¦å†™æ–¹å‘é€‰é¡¹ -->
                <div class="space-y-3" id="verticalDirectionOptions" style="display: none;"> <!-- åˆå§‹éšè— -->
                    <label for="verticalDirection"
                        class="block text-lg font-semibold text-gray-700 mb-2">å‚ç›´ä¹¦å†™æ–¹å‘:</label>
                    <select id="verticalDirection"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="ltr">ä»å·¦åˆ°å³</option>
                        <option value="rtl">ä»å³åˆ°å·¦</option>
                    </select>
                </div>

                <!-- ç”ŸæˆæŒ‰é’® - å­—ä½“åŠ è½½åå¯ç”¨ -->
                <button id="generateBtn"
                    class="w-full bg-gradient-to-r from-purple-600 to-pink-500 text-white py-4 rounded-xl text-2xl font-bold hover:from-purple-700 hover:to-pink-600 focus:outline-none focus:ring-6 focus:ring-purple-400 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95"
                    disabled>ç”Ÿæˆå›¾ç‰‡ (åŠ è½½ä¸­...)</button>

                <div id="loadingIndicator"
                    class="hidden text-center text-purple-600 font-semibold text-lg mt-4 animate-pulse">
                    æ­£åœ¨ç”Ÿæˆå›¾ç‰‡ï¼Œè¯·ç¨å€™...
                </div>
            </div>

            <!-- å›¾ç‰‡é¢„è§ˆåŒº -->
            <div
                class="bg-gray-100 p-8 rounded-2xl shadow-inner flex items-center justify-center min-h-[400px] border border-gray-200 relative overflow-hidden">
                <img id="outputImage" class="max-w-full h-auto rounded-lg shadow-xl" alt="ç”Ÿæˆçš„å›¾ç‰‡"
                    style="max-height: 500px; display: none;">
                <canvas id="outputCanvas" class="border border-gray-300 rounded-lg shadow-md"></canvas>
                <p id="placeholderText" class="text-gray-500 text-center text-xl font-medium">è¾“å…¥æ–‡å­—å¹¶è°ƒæ•´è®¾ç½®ä»¥ç”Ÿæˆå›¾ç‰‡</p>
            </div>
        </div>

        <!-- åº•éƒ¨æ“ä½œæŒ‰é’® -->
        <div class="mt-10 flex justify-center space-x-6">
            <a id="downloadBtn" download="generated_text_image.png"
                class="hidden bg-gradient-to-r from-green-500 to-teal-500 text-white py-3 px-8 rounded-xl text-lg font-semibold hover:from-green-600 hover:to-teal-600 focus:outline-none focus:ring-6 focus:ring-green-300 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95">ä¸‹è½½å›¾ç‰‡</a>
            <button id="copyBtn"
                class="hidden bg-gradient-to-r from-blue-500 to-cyan-500 text-white py-3 px-8 rounded-xl text-lg font-semibold hover:from-blue-600 hover:to-cyan-600 focus:outline-none focus:ring-6 focus:ring-blue-300 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95">å¤åˆ¶å›¾ç‰‡é“¾æ¥</button>
            <div id="messageBox"
                class="fixed bottom-8 right-8 bg-black bg-opacity-80 text-white py-3 px-6 rounded-lg shadow-xl text-sm hidden z-50">
            </div>
        </div>

        <!-- Mobile Save Tip -->
        <div id="mobileSaveTip"
            class="hidden text-center mt-8 p-4 bg-yellow-50 border border-yellow-200 text-yellow-800 rounded-lg shadow-sm">
            <p class="font-semibold text-lg mb-2">ğŸ“¢ æ‰‹æœºç«¯ä¿å­˜æç¤ºï¼š</p>
            <p class="text-base">
                ç”±äºç³»ç»Ÿé™åˆ¶ï¼Œç½‘é¡µæ— æ³•ç›´æ¥ä¿å­˜å›¾ç‰‡åˆ°ç›¸å†Œã€‚
                è¯·åœ¨ä¸Šæ–¹ç”Ÿæˆçš„å›¾ç‰‡ä¸Š **é•¿æŒ‰ï¼ˆæˆ–é‡æŒ‰ï¼‰**ï¼Œç„¶åé€‰æ‹©èœå•ä¸­çš„ **â€œä¿å­˜å›¾ç‰‡â€** æˆ– **â€œæ·»åŠ åˆ°ç…§ç‰‡â€** å³å¯ä¿å­˜åˆ°æ‚¨çš„è®¾å¤‡ç›¸å†Œã€‚
            </p>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get all necessary DOM elements
            const inputText = document.getElementById('inputText');
            const fontSelect = document.getElementById('fontSelect');
            const backgroundSelect = document.getElementById('backgroundSelect');
            const customBgUploadContainer = document.getElementById('customBgUploadContainer');
            const customBgUpload = document.getElementById('customBgUpload');
            // Background color pickers and gradient options
            const solidColorContainer = document.getElementById('solidColorContainer');
            const solidColorPicker = document.getElementById('solidColorPicker');
            const gradientColorContainer = document.getElementById('gradientColorContainer');
            const gradientStartColor = document.getElementById('gradientStartColor');
            const gradientEndColor = document.getElementById('gradientEndColor');
            const gradientAngleInput = document.getElementById('gradientAngleInput'); // New gradient angle input
            const gradientAngleValueSpan = document.getElementById('gradientAngleValue'); // New gradient angle value span


            const textColorInput = document.getElementById('textColor');
            const fontSizeInput = document.getElementById('fontSize');
            const fontSizeValueSpan = document.getElementById('fontSizeValue');
            const charSpacingInput = document.getElementById('charSpacing');
            const charSpacingValueSpan = document.getElementById('charSpacingValue');
            const lineSpacingFactorInput = document.getElementById('lineSpacingFactor');
            const lineSpacingFactorValueSpan = document.getElementById('lineSpacingFactorValue');
            const textAlignmentSelect = document.getElementById('textAlignment');
            const topOffsetInput = document.getElementById('topOffset');
            const topOffsetValueSpan = document.getElementById('topOffsetValue');
            const randomnessIntensityInput = document.getElementById('randomnessIntensity');
            const randomnessIntensityValueSpan = document.getElementById('randomnessIntensityValue');
            const lineSkewAngleInput = document.getElementById('lineSkewAngle');
            const lineSkewAngleValueSpan = document.getElementById('lineSkewAngleValue');
            const verticalWritingCheckbox = document.getElementById('verticalWriting');
            const verticalDirectionOptions = document.getElementById('verticalDirectionOptions');
            const verticalDirectionSelect = document.getElementById('verticalDirection');
            const generateBtn = document.getElementById('generateBtn');
            const outputImage = document.getElementById('outputImage');
            const outputCanvas = document.getElementById('outputCanvas');
            const downloadBtn = document.getElementById('downloadBtn');
            const copyBtn = document.getElementById('copyBtn');
            const placeholderText = document.getElementById('placeholderText');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const messageBox = document.getElementById('messageBox');
            const mobileSaveTip = document.getElementById('mobileSaveTip');
            const ctx = outputCanvas.getContext('2d');

            // Custom Font DOM elements
            const customFontUploadContainer = document.getElementById('customFontUploadContainer');
            const customFontUploadInput = document.getElementById('customFontUploadInput');
            const fontUploadStatus = document.getElementById('fontUploadStatus');


            // Fixed Canvas dimensions for 9:16 aspect ratio
            const CANVAS_WIDTH = 720;
            const CANVAS_HEIGHT = 1280;
            const BASE_PADDING = 60; // Base padding from canvas edges

            let debounceTimer; // For debouncing text input
            let uploadedBgImage = null; // Store the uploaded background image object
            let customFontLoaded = false; // Track if a custom font has been successfully loaded

            // Function to debounce calls
            const debounce = (func, delay) => {
                return function (...args) {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => func.apply(this, args), delay);
                };
            };

            // Initially disable the generate button, enable after fonts load
            generateBtn.disabled = true;
            generateBtn.textContent = 'ç”Ÿæˆå›¾ç‰‡ (åŠ è½½ä¸­...)';

            // Wait for all Google Fonts to be loaded
            document.fonts.ready.then(() => {
                generateBtn.disabled = false;
                generateBtn.textContent = 'ç”Ÿæˆå›¾ç‰‡';
                // Trigger initial image generation once fonts are loaded
                generateImage(); // Initial render

                // Attach event listeners for real-time updates
                inputText.addEventListener('input', debounce(generateImage, 500)); // Debounce text input
                fontSelect.addEventListener('change', () => {
                    // Toggle custom font upload container visibility
                    if (fontSelect.value === 'CustomUploadedFont') {
                        customFontUploadContainer.classList.remove('hidden');
                    } else {
                        customFontUploadContainer.classList.add('hidden');
                        // Reset custom font status if switching away
                        fontUploadStatus.textContent = 'è¯·ä¸Šä¼ å­—ä½“æ–‡ä»¶ï¼Œå¦‚ TTF, OTF, WOFF, WOFF2 æ ¼å¼ã€‚';
                        fontUploadStatus.classList.remove('text-green-600', 'text-red-600', 'text-purple-600');
                        fontUploadStatus.classList.add('text-gray-600');
                    }
                    generateImage();
                });
                customFontUploadInput.addEventListener('change', handleFontUpload); // Handle font upload

                // Background selection change handler
                backgroundSelect.addEventListener('change', () => {
                    const selectedBg = backgroundSelect.value;
                    // Hide all background-specific containers first
                    customBgUploadContainer.classList.add('hidden');
                    solidColorContainer.classList.add('hidden');
                    gradientColorContainer.classList.add('hidden');
                    uploadedBgImage = null; // Clear custom image if switching away

                    // Show the relevant container based on selection
                    if (selectedBg === 'custom') {
                        customBgUploadContainer.classList.remove('hidden');
                    } else if (selectedBg === 'solid') {
                        solidColorContainer.classList.remove('hidden');
                    } else if (selectedBg === 'gradient') {
                        gradientColorContainer.classList.remove('hidden');
                    }
                    generateImage();
                });
                customBgUpload.addEventListener('change', handleImageUpload); // Handle background image upload

                // Listeners for solid and gradient color pickers/selectors
                solidColorPicker.addEventListener('input', generateImage);
                gradientStartColor.addEventListener('input', generateImage);
                gradientEndColor.addEventListener('input', generateImage);
                gradientAngleInput.addEventListener('input', generateImage); // New listener for gradient angle


                textColorInput.addEventListener('input', generateImage);
                fontSizeInput.addEventListener('input', generateImage);
                charSpacingInput.addEventListener('input', generateImage);
                lineSpacingFactorInput.addEventListener('input', generateImage);
                textAlignmentSelect.addEventListener('change', generateImage);
                topOffsetInput.addEventListener('input', generateImage);
                randomnessIntensityInput.addEventListener('input', generateImage);
                lineSkewAngleInput.addEventListener('input', generateImage);
                verticalWritingCheckbox.addEventListener('change', () => {
                    // Toggle vertical writing options visibility and enable/disable horizontal alignment
                    if (verticalWritingCheckbox.checked) {
                        verticalDirectionOptions.style.display = 'block';
                        textAlignmentSelect.disabled = true;
                        textAlignmentSelect.value = 'left'; // Reset to left if user unchecks later
                    } else {
                        verticalDirectionOptions.style.display = 'none';
                        textAlignmentSelect.disabled = false;
                    }
                    generateImage(); // Trigger update immediately on checkbox change
                });
                verticalDirectionSelect.addEventListener('change', generateImage);

                // Show mobile save tip if on a mobile device
                if (/Mobi|Android/i.test(navigator.userAgent)) {
                    mobileSaveTip.classList.remove('hidden');
                }

            }).catch(error => {
                console.error("å­—ä½“åŠ è½½å¤±è´¥:", error);
                showMessage("å­—ä½“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚");
                generateBtn.textContent = 'å­—ä½“åŠ è½½å¤±è´¥';
            });

            // Handle custom font upload
            async function handleFontUpload(event) {
                const file = event.target.files[0];
                if (!file) {
                    fontUploadStatus.textContent = 'æœªé€‰æ‹©å­—ä½“æ–‡ä»¶ã€‚';
                    fontUploadStatus.classList.remove('hidden', 'text-green-600', 'text-red-600', 'text-purple-600');
                    fontUploadStatus.classList.add('text-gray-600');
                    customFontLoaded = false;
                    generateImage(); // Trigger redraw with current (possibly default) font
                    return;
                }

                fontUploadStatus.textContent = 'æ­£åœ¨åŠ è½½å­—ä½“...';
                fontUploadStatus.classList.remove('hidden', 'text-green-600', 'text-red-600', 'text-gray-600');
                fontUploadStatus.classList.add('text-purple-600');
                customFontLoaded = false; // Reset status

                try {
                    const fontName = 'CustomUploadedFont'; // Fixed name for simplicity
                    const fontUrl = URL.createObjectURL(file); // Create URL for the font file

                    // Remove any previously loaded custom font with the same name
                    for (const f of document.fonts.values()) {
                        if (f.family === fontName) {
                            document.fonts.delete(f);
                            break;
                        }
                    }

                    const customFontFace = new FontFace(fontName, `url(${fontUrl})`);
                    await customFontFace.load(); // Load the font
                    document.fonts.add(customFontFace); // Add to document fonts
                    URL.revokeObjectURL(fontUrl); // Clean up the object URL

                    fontUploadStatus.textContent = `å­—ä½“ "${file.name}" åŠ è½½æˆåŠŸï¼`;
                    fontUploadStatus.classList.remove('text-purple-600', 'text-red-600', 'text-gray-600');
                    fontUploadStatus.classList.add('text-green-600');
                    customFontLoaded = true; // Mark as loaded

                    fontSelect.value = fontName; // Select the custom font in the dropdown
                    generateImage(); // Regenerate image with the new font
                } catch (error) {
                    console.error("åŠ è½½è‡ªå®šä¹‰å­—ä½“å¤±è´¥:", error);
                    fontUploadStatus.textContent = `åŠ è½½è‡ªå®šä¹‰å­—ä½“å¤±è´¥: ${error.message || 'æ–‡ä»¶æŸåæˆ–æ ¼å¼ä¸æ­£ç¡®'}`;
                    fontUploadStatus.classList.remove('text-purple-600', 'text-green-600', 'text-gray-600');
                    fontUploadStatus.classList.add('text-red-600');
                    customFontLoaded = false; // Mark as failed
                    // If custom font failed, ensure we revert to a default working font or alert user to change selection
                    if (fontSelect.value === 'CustomUploadedFont') {
                        fontSelect.value = 'LXGW WenKai Lite'; // Fallback to a default font
                        generateImage();
                    }
                }
            }


            // Handle custom background image upload
            function handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) {
                    uploadedBgImage = null; // Clear if no file selected
                    generateImage(); // Regenerate with current background
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedBgImage = img; // Store the loaded image
                        generateImage(); // Regenerate with new custom background
                    };
                    img.onerror = () => {
                        showMessage('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·å°è¯•å…¶ä»–å›¾ç‰‡ã€‚');
                        uploadedBgImage = null;
                        generateImage(); // Fallback
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    showMessage('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
                    uploadedBgImage = null;
                    generateImage(); // Fallback
                };
                reader.readAsDataURL(file);
            }


            // Update slider value displays and trigger image generation
            fontSizeInput.addEventListener('input', () => {
                fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
                generateImage();
            });
            charSpacingInput.addEventListener('input', () => {
                charSpacingValueSpan.textContent = `${charSpacingInput.value}px`;
                generateImage();
            });
            lineSpacingFactorInput.addEventListener('input', () => {
                lineSpacingFactorValueSpan.textContent = `${lineSpacingFactorInput.value}%`;
                generateImage();
            });
            topOffsetInput.addEventListener('input', () => {
                topOffsetValueSpan.textContent = `${topOffsetInput.value}%`;
                generateImage();
            });
            randomnessIntensityInput.addEventListener('input', () => {
                randomnessIntensityValueSpan.textContent = randomnessIntensityInput.value;
                generateImage();
            });
            lineSkewAngleInput.addEventListener('input', () => {
                lineSkewAngleValueSpan.textContent = `${lineSkewAngleInput.value}Â°`;
                generateImage();
            });
            gradientAngleInput.addEventListener('input', () => { // New listener for gradient angle
                gradientAngleValueSpan.textContent = `${gradientAngleInput.value}Â°`;
                generateImage();
            });


            // Show message box temporarily
            function showMessage(message) {
                messageBox.textContent = message;
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 3000); // Hide after 3 seconds
            }

            // Function to draw text on canvas
            function drawHandwrittenText(context, text, font, textColor, fontSize, startX, startY, maxWidth, alignment, randomnessIntensity, lineSkewAngle, isVertical, verticalDirection, charSpacing, lineSpacingFactor) {
                console.log("drawHandwrittenText: å¼€å§‹ç»˜åˆ¶æ–‡å­—...");
                console.log(`- å­—ä½“: ${font}, å¤§å°: ${fontSize}px, é¢œè‰²: ${textColor}`);
                console.log(`- èµ·å§‹åæ ‡: (${startX}, ${startY}), æœ€å¤§å®½åº¦: ${maxWidth}`);
                console.log(`- å¯¹é½: ${alignment}, æŠ–åŠ¨: ${randomnessIntensity}, å€¾æ–œ: ${lineSkewAngle}Â°`);
                console.log(`- å‚ç›´æ¨¡å¼: ${isVertical}, æ–¹å‘: ${verticalDirection}, å­—é—´è·: ${charSpacing}, è¡Œé—´è·å› å­: ${lineSpacingFactor}%`);

                context.fillStyle = textColor;
                context.font = `${fontSize}px "${font}"`; // Use the selected font family
                context.textBaseline = 'top';

                const textLines = text.split('\n'); // Preserve user's newlines

                if (isVertical) {
                    console.log("drawHandwrittenText: å‚ç›´æ¨¡å¼");
                    let currentColumnX;
                    const effectiveCharHeight = fontSize * (lineSpacingFactor / 100);
                    const baseColumnAdvance = fontSize + charSpacing;

                    if (verticalDirection === 'rtl') {
                        currentColumnX = CANVAS_WIDTH - BASE_PADDING - fontSize;
                    } else {
                        currentColumnX = startX;
                    }

                    let currentColumnY = startY;

                    for (let lineIndex = 0; lineIndex < textLines.length; lineIndex++) {
                        const lineContent = textLines[lineIndex];

                        if (lineIndex > 0 || (currentColumnY > startY && lineContent.length > 0)) {
                            if (verticalDirection === 'rtl') {
                                currentColumnX -= (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                            } else {
                                currentColumnX += (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                            }
                            currentColumnY = startY;

                            if (verticalDirection === 'rtl' && currentColumnX < BASE_PADDING - (fontSize / 2)) {
                                showMessage(`å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å·¦ä¾§è¾¹ç•Œï¼Œè¯·å‡å°‘å†…å®¹æˆ–è°ƒæ•´è®¾ç½®ã€‚å½“å‰X: ${currentColumnX.toFixed(2)}`);
                                console.warn("å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å·¦ä¾§è¾¹ç•Œï¼Œåœæ­¢ç»˜åˆ¶ã€‚");
                                return;
                            }
                            if (verticalDirection === 'ltr' && currentColumnX + fontSize > CANVAS_WIDTH - BASE_PADDING + (fontSize / 2)) {
                                showMessage(`å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å³ä¾§è¾¹ç•Œï¼Œè¯·å‡å°‘å†…å®¹æˆ–è°ƒæ•´è®¾ç½®ã€‚å½“å‰X: ${currentColumnX.toFixed(2)}`);
                                console.warn("å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å³ä¾§è¾¹ç•Œï¼Œåœæ­¢ç»˜åˆ¶ã€‚");
                                return;
                            }
                        }
                        console.log(`- ç»˜åˆ¶åˆ— (è¡Œ ${lineIndex + 1}): X=${currentColumnX.toFixed(2)}, Y=${currentColumnY.toFixed(2)}`);

                        for (let i = 0; i < lineContent.length; i++) {
                            const char = lineContent[i];

                            if (char === ' ') {
                                currentColumnY += effectiveCharHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5;
                                console.log(`  è·³è¿‡ç©ºæ ¼ã€‚ä¸‹ä¸€å­—ç¬¦Y: ${currentColumnY.toFixed(2)}`);
                                continue;
                            }

                            const charXJitter = (Math.random() - 0.5) * randomnessIntensity;
                            const charYJitter = (Math.random() - 0.5) * randomnessIntensity;

                            context.save();
                            context.translate(currentColumnX + charXJitter, currentColumnY + charYJitter);

                            const randomCharSkewRad = ((Math.random() - 0.5) * lineSkewAngle) * Math.PI / 180;
                            context.rotate(randomCharSkewRad);

                            context.textAlign = 'center';
                            context.fillText(char, 0, 0);
                            console.log(`  ç»˜åˆ¶å­—ç¬¦: "${char}" @(${currentColumnX.toFixed(2)}, ${currentColumnY.toFixed(2)}), æŠ–åŠ¨: (${charXJitter.toFixed(2)}, ${charYJitter.toFixed(2)}), å€¾æ–œ: ${randomCharSkewRad.toFixed(2)}rad`);

                            context.restore();

                            currentColumnY += effectiveCharHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5;

                            if (currentColumnY + fontSize > CANVAS_HEIGHT - BASE_PADDING) {
                                console.log(`  åˆ—å·²æ»¡ã€‚å½“å‰Y: ${currentColumnY.toFixed(2)}, ç”»å¸ƒåº•éƒ¨é™åˆ¶: ${CANVAS_HEIGHT - BASE_PADDING}. åˆ‡æ¢åˆ°ä¸‹ä¸€åˆ—ã€‚`);
                                currentColumnY = startY;
                                if (verticalDirection === 'rtl') {
                                    currentColumnX -= (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                                } else {
                                    currentColumnX += (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                                }

                                if (verticalDirection === 'rtl' && currentColumnX < BASE_PADDING - (fontSize / 2)) {
                                    showMessage('å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å·¦ä¾§è¾¹ç•Œï¼Œè¯·å‡å°‘å†…å®¹æˆ–è°ƒæ•´è®¾ç½®ã€‚');
                                    console.warn("å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å·¦ä¾§è¾¹ç•Œï¼Œåœæ­¢ç»˜åˆ¶ã€‚");
                                    return;
                                }
                                if (verticalDirection === 'ltr' && currentColumnX + fontSize > CANVAS_WIDTH - BASE_PADDING + (fontSize / 2)) {
                                    showMessage('å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å³ä¾§è¾¹ç•Œï¼Œè¯·å‡å°‘å†…å®¹æˆ–è°ƒæ•´è®¾ç½®ã€‚');
                                    console.warn("å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å³ä¾§è¾¹ç•Œï¼Œåœæ­¢ç»˜åˆ¶ã€‚");
                                    return;
                                }
                            }
                        }
                    }

                } else {
                    console.log("drawHandwrittenText: æ°´å¹³æ¨¡å¼");
                    let currentY = startY;
                    const effectiveLineHeight = fontSize * (lineSpacingFactor / 100);

                    for (let i = 0; i < textLines.length; i++) {
                        const line = textLines[i];
                        if (line === '') {
                            currentY += effectiveLineHeight;
                            console.log(`- è·³è¿‡ç©ºè¡Œã€‚ä¸‹ä¸€è¡ŒY: ${currentY.toFixed(2)}`);
                            continue;
                        }

                        const lineYJitter = (Math.random() - 0.5) * randomnessIntensity;
                        let lineActualY = currentY + lineYJitter;

                        const randomLineSkewRad = ((Math.random() - 0.5) * lineSkewAngle) * Math.PI / 180;

                        context.save();

                        let translationX;
                        let estimatedLineWidth = 0;
                        for (let k = 0; k < line.length; k++) {
                            estimatedLineWidth += context.measureText(line[k]).width;
                        }
                        estimatedLineWidth += (line.length - 1) * charSpacing;


                        if (alignment === 'center') {
                            translationX = (CANVAS_WIDTH / 2) - (estimatedLineWidth / 2);
                        } else if (alignment === 'right') {
                            translationX = CANVAS_WIDTH - BASE_PADDING - estimatedLineWidth;
                        } else {
                            translationX = startX;
                        }

                        translationX = Math.max(BASE_PADDING, translationX);
                        if (translationX + estimatedLineWidth > CANVAS_WIDTH - BASE_PADDING) {
                            translationX = CANVAS_WIDTH - BASE_PADDING - estimatedLineWidth;
                        }

                        context.translate(translationX, lineActualY);
                        context.rotate(randomLineSkewRad);

                        let charDrawX = 0;

                        console.log(`- ç»˜åˆ¶è¡Œ: "${line}" @(${translationX.toFixed(2)}, ${lineActualY.toFixed(2)}), å€¾æ–œ: ${randomLineSkewRad.toFixed(2)}rad`);
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            const charWidth = context.measureText(char).width;

                            const charXJitter = (Math.random() - 0.5) * randomnessIntensity;
                            const charYJitter = (Math.random() - 0.5) * randomnessIntensity;

                            context.fillText(char, charDrawX + charXJitter, charYJitter);
                            charDrawX += charWidth + charSpacing;
                            console.log(`  ç»˜åˆ¶å­—ç¬¦: "${char}" @(${charDrawX.toFixed(2)}, ${charYJitter.toFixed(2)}), æŠ–åŠ¨: (${charXJitter.toFixed(2)}, ${charYJitter.toFixed(2)})`);
                        }

                        context.restore();

                        currentY += effectiveLineHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5;

                        if (currentY + fontSize > (CANVAS_HEIGHT - BASE_PADDING)) {
                            showMessage(`æ–‡å­—å†…å®¹è¿‡å¤šï¼Œå¯èƒ½è¶…å‡ºå›¾ç‰‡èŒƒå›´ã€‚å½“å‰Y: ${currentY.toFixed(2)}, ç”»å¸ƒåº•éƒ¨é™åˆ¶: ${CANVAS_HEIGHT - BASE_PADDING}`);
                            console.warn("æ°´å¹³æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡èŒƒå›´ï¼Œåœæ­¢ç»˜åˆ¶ã€‚");
                            break;
                        }
                    }
                }
            }


            // Generate Image function
            async function generateImage() {
                const text = inputText.value; // Get raw text, don't trim to preserve spaces
                loadingIndicator.classList.remove('hidden');
                placeholderText.classList.add('hidden'); // Hide placeholder when generating
                outputImage.style.display = 'none'; // Hide old image

                console.log("generateImage: å¼€å§‹ç”Ÿæˆå›¾ç‰‡...");
                console.log(`è¾“å…¥æ–‡æœ¬: "${text}"`);

                const selectedFont = fontSelect.value;
                const selectedBackground = backgroundSelect.value;
                const selectedTextColor = textColorInput.value;
                const fontSize = parseInt(fontSizeInput.value);
                const charSpacing = parseInt(charSpacingInput.value);
                const lineSpacingFactor = parseInt(lineSpacingFactorInput.value);

                const textAlignment = textAlignmentSelect.value;
                const topOffsetPercentage = parseInt(topOffsetInput.value);
                const topOffsetPixels = (topOffsetPercentage / 100) * CANVAS_HEIGHT;

                const randomnessIntensity = parseInt(randomnessIntensityInput.value);
                const lineSkewAngle = parseInt(lineSkewAngleInput.value);
                const isVerticalWriting = verticalWritingCheckbox.checked;
                const verticalDirection = verticalDirectionSelect.value;

                outputCanvas.width = CANVAS_WIDTH;
                outputCanvas.height = CANVAS_HEIGHT;
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height); // Explicitly clear canvas

                try {
                    // Draw background
                    if (selectedBackground === 'notebook') {
                        ctx.fillStyle = '#F0F8FF';
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

                        ctx.strokeStyle = '#ADD8E6';
                        ctx.lineWidth = 1;
                        const notebookLineHeight = fontSize * (lineSpacingFactor / 100);
                        for (let i = BASE_PADDING + topOffsetPixels; i < outputCanvas.height - BASE_PADDING; i += notebookLineHeight) {
                            ctx.beginPath();
                            ctx.moveTo(BASE_PADDING, i);
                            ctx.lineTo(outputCanvas.width - BASE_PADDING, i);
                            ctx.stroke();
                        }
                        ctx.strokeStyle = '#FF6347';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(BASE_PADDING + 20, 0);
                        ctx.lineTo(BASE_PADDING + 20, outputCanvas.height);
                        ctx.stroke();
                        console.log("èƒŒæ™¯: ç¬”è®°æœ¬");
                    } else if (selectedBackground === 'parchment-texture') {
                        drawParchmentTexture(ctx, outputCanvas.width, outputCanvas.height);
                        console.log("èƒŒæ™¯: ç¾Šçš®çº¸çº¹ç†");
                    } else if (selectedBackground === 'vintage-paper') {
                        drawVintagePaperTexture(ctx, outputCanvas.width, outputCanvas.height);
                        console.log("èƒŒæ™¯: å¤å¤çº¸å¼ ");
                    } else if (selectedBackground === 'custom') {
                        if (uploadedBgImage) {
                            const hRatio = CANVAS_WIDTH / uploadedBgImage.width;
                            const vRatio = CANVAS_HEIGHT / uploadedBgImage.height;
                            const ratio = Math.max(hRatio, vRatio);
                            const sWidth = uploadedBgImage.width * ratio;
                            const sHeight = uploadedBgImage.height * ratio;
                            const sx = (CANVAS_WIDTH - sWidth) / 2;
                            const sy = (CANVAS_HEIGHT - sHeight) / 2;
                            ctx.drawImage(uploadedBgImage, sx, sy, sWidth, sHeight);
                            console.log("èƒŒæ™¯: è‡ªå®šä¹‰å›¾ç‰‡");
                        } else {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                            showMessage('è¯·ä¸Šä¼ è‡ªå®šä¹‰èƒŒæ™¯å›¾ç‰‡ï¼');
                            console.warn("èƒŒæ™¯: è‡ªå®šä¹‰å›¾ç‰‡ä½†æœªä¸Šä¼ ï¼Œä½¿ç”¨ç™½è‰²èƒŒæ™¯ã€‚");
                        }
                    } else if (selectedBackground === 'solid') {
                        ctx.fillStyle = solidColorPicker.value;
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                        console.log(`èƒŒæ™¯: çº¯è‰² ${solidColorPicker.value}`);
                    } else if (selectedBackground === 'gradient') {
                        const startColor = gradientStartColor.value;
                        const endColor = gradientEndColor.value;
                        const angleInDegrees = parseInt(gradientAngleInput.value);

                        // Convert angle to radians and adjust for canvas coordinate system (0deg is usually right, we want top).
                        // HTML Canvas's createLinearGradient works with absolute coordinates for (x0, y0, x1, y1).
                        // To get a gradient line that fills the canvas at a specific angle:
                        // The line goes from (cx - cos(angle)*L, cy - sin(angle)*L) to (cx + cos(angle)*L, cy + sin(angle)*L)
                        // where L is half the diagonal length of the canvas, ensuring it covers the whole area.
                        const angleInRadians = (angleInDegrees - 90) * Math.PI / 180; // Adjust for 0deg being top-to-bottom

                        const center_x = CANVAS_WIDTH / 2;
                        const center_y = CANVAS_HEIGHT / 2;
                        const length = Math.sqrt(CANVAS_WIDTH * CANVAS_WIDTH + CANVAS_HEIGHT * CANVAS_HEIGHT) / 2; // Half diagonal

                        const x0 = center_x - Math.cos(angleInRadians) * length;
                        const y0 = center_y - Math.sin(angleInRadians) * length;
                        const x1 = center_x + Math.cos(angleInRadians) * length;
                        const y1 = center_y + Math.sin(angleInRadians) * length;

                        const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                        gradient.addColorStop(0, startColor);
                        gradient.addColorStop(1, endColor);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                        console.log(`èƒŒæ™¯: æ¸å˜è‰² ${startColor} -> ${endColor}, è§’åº¦: ${angleInDegrees}Â°`);
                    }
                    else { // Default to white if none selected or unknown value
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                        console.log("èƒŒæ™¯: é»˜è®¤çº¯ç™½ï¼ˆæœªçŸ¥æˆ–æœªé€‰ï¼‰");
                    }

                    // Draw text only if there's *any* content, including spaces, for consistency
                    if (text.length === 0) { // Check raw length for truly empty
                        placeholderText.classList.remove('hidden');
                        outputImage.style.display = 'none';
                        downloadBtn.classList.add('hidden');
                        copyBtn.classList.add('hidden');
                        console.log("æ–‡æœ¬ä¸ºç©ºï¼Œæ˜¾ç¤ºå ä½ç¬¦ã€‚");
                    } else {
                        drawHandwrittenText(
                            ctx,
                            text,
                            selectedFont,
                            selectedTextColor,
                            fontSize,
                            BASE_PADDING,
                            BASE_PADDING + topOffsetPixels,
                            CANVAS_WIDTH - BASE_PADDING * 2,
                            textAlignment,
                            randomnessIntensity,
                            lineSkewAngle,
                            isVerticalWriting,
                            verticalDirection,
                            charSpacing,
                            lineSpacingFactor
                        );

                        // Convert Canvas content to image
                        const imageDataUrl = outputCanvas.toDataURL('image/png');
                        outputImage.src = imageDataUrl;
                        outputImage.style.display = 'block';
                        downloadBtn.href = imageDataUrl;
                        downloadBtn.classList.remove('hidden');
                        copyBtn.classList.remove('hidden');
                        console.log("å›¾ç‰‡ç”ŸæˆæˆåŠŸã€‚");
                    }

                } catch (error) {
                    console.error("ç”Ÿæˆå›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯:", error);
                    showMessage("ç”Ÿæˆå›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥æˆ–åˆ·æ–°é¡µé¢ã€‚");
                    placeholderText.classList.remove('hidden');
                    outputImage.style.display = 'none';
                    downloadBtn.classList.add('hidden');
                    copyBtn.classList.add('hidden');
                } finally {
                    loadingIndicator.classList.add('hidden');
                    console.log("ç”Ÿæˆå›¾ç‰‡è¿‡ç¨‹ç»“æŸã€‚");
                }
            }

            // Copy image link functionality
            copyBtn.addEventListener('click', () => {
                const imageDataUrl = outputImage.src;
                if (imageDataUrl) {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = imageDataUrl;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        document.execCommand('copy');
                        showMessage('å›¾ç‰‡é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                    } catch (err) {
                        showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚');
                    }
                    document.body.removeChild(tempInput);
                } else {
                    showMessage('è¯·å…ˆç”Ÿæˆå›¾ç‰‡ï¼');
                }
            });

            // Initial display for sliders
            fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
            charSpacingValueSpan.textContent = `${charSpacingInput.value}px`;
            lineSpacingFactorValueSpan.textContent = `${lineSpacingFactorInput.value}%`;
            topOffsetValueSpan.textContent = `${topOffsetInput.value}%`;
            randomnessIntensityValueSpan.textContent = randomnessIntensityInput.value;
            lineSkewAngleValueSpan.textContent = `${lineSkewAngleInput.value}Â°`;
            gradientAngleValueSpan.textContent = `${gradientAngleInput.value}Â°`; // Initial display for gradient angle

            // Canvas background drawing functions (retained from previous versions)
            function drawParchmentTexture(context, width, height) {
                context.fillStyle = '#F5DEB3';
                context.fillRect(0, 0, width, height);
                for (let i = 0; i < 8000; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 0.6 + 0.1;
                    const alpha = Math.random() * 0.2 + 0.1;
                    const color = Math.random() < 0.5 ? 'rgba(0,0,0,' : 'rgba(255,255,255,';
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = color + alpha + ')';
                    context.fill();
                }
            }

            function drawVintagePaperTexture(context, width, height) {
                context.fillStyle = '#FDF6E3';
                context.fillRect(0, 0, width, height);
                for (let i = 0; i < 80; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 40 + 15;
                    const alpha = Math.random() * 0.12 + 0.08;
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = `rgba(139,69,19,${alpha})`;
                    context.fill();
                }
                context.strokeStyle = `rgba(139,69,19,0.05)`;
                context.lineWidth = 0.8;
                for (let i = 0; i < 30; i++) {
                    context.beginPath();
                    context.moveTo(Math.random() * width, Math.random() * height);
                    context.lineTo(Math.random() * width, Math.random() * height);
                    context.stroke();
                }
            }
        });
    </script>
</body>

</html>