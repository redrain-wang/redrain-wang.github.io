<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手写体文字图片生成器</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Google Fonts Import for UI and Handwriting Fonts */
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Smiley+Sans&family=LXGW+WenKai+Lite&family=Ma+Shan+Zheng&family=Liu+Jian+Mao+Cao&family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            /* 使用Inter作为UI界面的默认字体 */
        }

        /* Custom Handwriting Font Styles */
        .font-zcool-kuaile {
            font-family: 'ZCOOL KuaiLe', cursive;
        }

        .font-smiley-sans {
            font-family: 'Smiley Sans', sans-serif;
        }

        .font-lxgw-wenkai {
            font-family: 'LXGW WenKai Lite', cursive;
            /* Using Lite version for broader compatibility */
        }

        .font-ma-shan-zheng {
            font-family: 'Ma Shan Zheng', cursive;
        }

        .font-liu-jian-mao-cao {
            font-family: 'Liu Jian Mao Cao', cursive;
        }

        /* Hide Canvas, only show Image */
        #outputCanvas {
            display: none;
        }

        /* Custom Slider Styles */
        input[type='range']::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            /* purple-500 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
            /* purple-500 with opacity */
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }

        input[type='range']::-webkit-slider-thumb:hover {
            background: #7c3aed;
            /* purple-600 */
        }

        input[type='range']::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }

        input[type='range']::-moz-range-thumb:hover {
            background: #7c3aed;
        }
    </style>
</head>

<body
    class="bg-gradient-to-br from-purple-100 via-pink-100 to-blue-200 min-h-screen flex items-center justify-center p-6 text-gray-800">

    <div
        class="bg-white p-10 rounded-3xl shadow-2xl max-w-5xl w-full border border-gray-100 transform transition-all duration-300 hover:scale-[1.005]">
        <h1
            class="text-5xl font-extrabold text-center text-purple-700 mb-10 tracking-tight flex items-center justify-center space-x-3">
            <svg class="w-10 h-10 text-pink-500" fill="currentColor" viewBox="0 0 20 20"
                xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd"
                    d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828zM4 12a2 2 0 012-2h.01a.75.75 0 100-1.5H6a3.5 3.5 0 00-3.5 3.5v1.5a.75.75 0 001.5 0V12zM15 15a.75.75 0 00-.75.75v1.5a.75.75 0 01-.75.75H4a2 2 0 01-2-2v-1.5a.75.75 0 00-1.5 0v1.5a3.5 3.5 0 003.5 3.5h9.5a3.5 3.5 0 003.5-3.5v-1.5a.75.75 0 00-1.5 0V15z"
                    clip-rule="evenodd"></path>
            </svg>
            <span>手写体文字图片生成器</span>
        </h1>

        <div class="grid md:grid-cols-2 gap-10">
            <!-- 设置表单 -->
            <div class="space-y-7">
                <div>
                    <label for="inputText" class="block text-lg font-semibold text-gray-700 mb-2">输入文字:</label>
                    <textarea id="inputText"
                        class="w-full p-4 border border-gray-300 rounded-xl focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base h-40 resize-y shadow-sm hover:shadow-md"
                        placeholder="在这里输入你想要生成手写体的文字...（回车和空格会被保留）"></textarea>
                </div>

                <div>
                    <label for="fontSelect" class="block text-lg font-semibold text-gray-700 mb-2">选择字体:</label>
                    <select id="fontSelect"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="LXGW WenKai Lite">霞鹜文楷 (LXGW WenKai Lite)</option>
                        <option value="ZCOOL KuaiLe">站酷快乐体 (ZCOOL KuaiLe)</option>
                        <option value="Smiley Sans">得意黑 (Smiley Sans)</option>
                        <option value="Ma Shan Zheng">马善政 (Ma Shan Zheng)</option>
                        <option value="Liu Jian Mao Cao">刘江毛草 (Liu Jian Mao Cao)</option>
                    </select>
                </div>

                <div>
                    <label for="backgroundSelect" class="block text-lg font-semibold text-gray-700 mb-2">选择背景:</label>
                    <select id="backgroundSelect"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="notebook">笔记本</option>
                        <option value="parchment-texture">羊皮纸纹理</option>
                        <option value="vintage-paper">复古纸张</option>
                        <option value="white">纯白</option>
                        <option value="custom">自定义图片</option>
                    </select>
                </div>

                <!-- 自定义背景上传 -->
                <div id="customBgUploadContainer" class="hidden">
                    <label for="customBgUpload"
                        class="block text-lg font-semibold text-gray-700 mb-2">上传自定义背景图片:</label>
                    <input type="file" id="customBgUpload" accept="image/*"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md cursor-pointer">
                    <span class="block text-sm text-gray-600 mt-1">支持 JPG, PNG 等格式。图片将自动缩放以覆盖整个背景。</span>
                </div>


                <div>
                    <label for="textColor" class="block text-lg font-semibold text-gray-700 mb-2">文字颜色:</label>
                    <input type="color" id="textColor" value="#333333"
                        class="w-full h-12 border border-gray-300 rounded-xl cursor-pointer focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out shadow-sm hover:shadow-md">
                </div>

                <div>
                    <label for="fontSize" class="block text-lg font-semibold text-gray-700 mb-2">字体大小:</label>
                    <input type="range" id="fontSize" min="20" max="80" value="40"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="fontSizeValue" class="block text-sm text-gray-600 mt-2 text-right">40px</span>
                </div>

                <!-- 新增字间距和行间距 -->
                <div>
                    <label for="charSpacing" class="block text-lg font-semibold text-gray-700 mb-2">字间距:</label>
                    <input type="range" id="charSpacing" min="-10" max="20" value="0"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="charSpacingValue" class="block text-sm text-gray-600 mt-2 text-right">0px</span>
                    <span class="block text-sm text-gray-600 mt-1">调整字符之间的额外空间。</span>
                </div>

                <div>
                    <label for="lineSpacingFactor" class="block text-lg font-semibold text-gray-700 mb-2">行间距:</label>
                    <input type="range" id="lineSpacingFactor" min="80" max="200" value="100"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="lineSpacingFactorValue" class="block text-sm text-gray-600 mt-2 text-right">100%</span>
                    <span class="block text-sm text-gray-600 mt-1">调整行与行之间的额外空间 (100% 为默认)。</span>
                </div>


                <!-- 文字位置设置 -->
                <div>
                    <label for="textAlignment" class="block text-lg font-semibold text-gray-700 mb-2">文字位置 (水平):</label>
                    <select id="textAlignment"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="left">居左</option>
                        <option value="center">居中</option>
                        <option value="right">居右</option>
                    </select>
                </div>

                <div>
                    <label for="topOffset" class="block text-lg font-semibold text-gray-700 mb-2">距离顶部 (%):</label>
                    <input type="range" id="topOffset" min="0" max="20" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <!-- Max changed from 100 to 20 for typical usage -->
                    <span id="topOffsetValue" class="block text-sm text-gray-600 mt-2 text-right">5%</span>
                    <span class="block text-sm text-gray-600 mt-1">设置文字内容块距离图片顶部的百分比。</span>
                </div>

                <!-- 随机抖动强度 -->
                <div>
                    <label for="randomnessIntensity"
                        class="block text-lg font-semibold text-gray-700 mb-2">随机抖动强度:</label>
                    <input type="range" id="randomnessIntensity" min="0" max="25" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <!-- Max increased to 25 -->
                    <span id="randomnessIntensityValue" class="block text-sm text-gray-600 mt-2 text-right">5</span>
                    <span class="block text-sm text-gray-600 mt-1">增加文字的随机偏移，模拟手写不规则感（0为无抖动）。</span>
                </div>

                <!-- 随机倾斜角度 -->
                <div>
                    <label for="lineSkewAngle" class="block text-lg font-semibold text-gray-700 mb-2">随机倾斜角度
                        (度):</label>
                    <input type="range" id="lineSkewAngle" min="0" max="10" value="0"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <!-- Max increased to 10 -->
                    <span id="lineSkewAngleValue" class="block text-sm text-gray-600 mt-2 text-right">0°</span>
                    <span class="block text-sm text-gray-600 mt-1">设置每行/字符的随机倾斜范围（0为无倾斜）。</span>
                </div>

                <!-- 垂直书写模式 -->
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="verticalWriting"
                        class="h-5 w-5 text-purple-600 rounded focus:ring-purple-500 cursor-pointer">
                    <label for="verticalWriting" class="text-lg font-semibold text-gray-700">垂直书写模式</label>
                </div>

                <!-- 垂直书写方向选项 -->
                <div class="space-y-3" id="verticalDirectionOptions" style="display: none;"> <!-- 初始隐藏 -->
                    <label for="verticalDirection"
                        class="block text-lg font-semibold text-gray-700 mb-2">垂直书写方向:</label>
                    <select id="verticalDirection"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="ltr">从左到右</option>
                        <option value="rtl">从右到左</option>
                    </select>
                </div>

                <!-- 生成按钮 - 字体加载后启用 -->
                <button id="generateBtn"
                    class="w-full bg-gradient-to-r from-purple-600 to-pink-500 text-white py-4 rounded-xl text-2xl font-bold hover:from-purple-700 hover:to-pink-600 focus:outline-none focus:ring-6 focus:ring-purple-400 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95"
                    disabled>生成图片 (加载中...)</button>

                <div id="loadingIndicator"
                    class="hidden text-center text-purple-600 font-semibold text-lg mt-4 animate-pulse">
                    正在生成图片，请稍候...
                </div>
            </div>

            <!-- 图片预览区 -->
            <div
                class="bg-gray-100 p-8 rounded-2xl shadow-inner flex items-center justify-center min-h-[400px] border border-gray-200 relative overflow-hidden">
                <img id="outputImage" class="max-w-full h-auto rounded-lg shadow-xl" alt="生成的图片"
                    style="max-height: 500px; display: none;">
                <canvas id="outputCanvas" class="border border-gray-300 rounded-lg shadow-md"></canvas>
                <p id="placeholderText" class="text-gray-500 text-center text-xl font-medium">输入文字并调整设置以生成图片</p>
            </div>
        </div>

        <!-- 底部操作按钮 -->
        <div class="mt-10 flex justify-center space-x-6">
            <a id="downloadBtn" download="handwritten_text.png"
                class="hidden bg-gradient-to-r from-green-500 to-teal-500 text-white py-3 px-8 rounded-xl text-lg font-semibold hover:from-green-600 hover:to-teal-600 focus:outline-none focus:ring-6 focus:ring-green-300 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95">下载图片</a>
            <button id="copyBtn"
                class="hidden bg-gradient-to-r from-blue-500 to-cyan-500 text-white py-3 px-8 rounded-xl text-lg font-semibold hover:from-blue-600 hover:to-cyan-600 focus:outline-none focus:ring-6 focus:ring-blue-300 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95">复制图片链接</button>
            <div id="messageBox"
                class="fixed bottom-8 right-8 bg-black bg-opacity-80 text-white py-3 px-6 rounded-lg shadow-xl text-sm hidden z-50">
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get all necessary DOM elements
            const inputText = document.getElementById('inputText');
            const fontSelect = document.getElementById('fontSelect');
            const backgroundSelect = document.getElementById('backgroundSelect');
            const customBgUploadContainer = document.getElementById('customBgUploadContainer'); // New
            const customBgUpload = document.getElementById('customBgUpload'); // New
            const textColorInput = document.getElementById('textColor');
            const fontSizeInput = document.getElementById('fontSize');
            const fontSizeValueSpan = document.getElementById('fontSizeValue');
            const charSpacingInput = document.getElementById('charSpacing'); // New
            const charSpacingValueSpan = document.getElementById('charSpacingValue'); // New
            const lineSpacingFactorInput = document.getElementById('lineSpacingFactor'); // New
            const lineSpacingFactorValueSpan = document.getElementById('lineSpacingFactorValue'); // New
            const textAlignmentSelect = document.getElementById('textAlignment');
            const topOffsetInput = document.getElementById('topOffset');
            const topOffsetValueSpan = document.getElementById('topOffsetValue');
            const randomnessIntensityInput = document.getElementById('randomnessIntensity');
            const randomnessIntensityValueSpan = document.getElementById('randomnessIntensityValue');
            const lineSkewAngleInput = document.getElementById('lineSkewAngle');
            const lineSkewAngleValueSpan = document.getElementById('lineSkewAngleValue');
            const verticalWritingCheckbox = document.getElementById('verticalWriting');
            const verticalDirectionOptions = document.getElementById('verticalDirectionOptions');
            const verticalDirectionSelect = document.getElementById('verticalDirection');
            const generateBtn = document.getElementById('generateBtn');
            const outputImage = document.getElementById('outputImage');
            const outputCanvas = document.getElementById('outputCanvas');
            const downloadBtn = document.getElementById('downloadBtn');
            const copyBtn = document.getElementById('copyBtn');
            const placeholderText = document.getElementById('placeholderText');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const messageBox = document.getElementById('messageBox');
            const ctx = outputCanvas.getContext('2d');

            // Fixed Canvas dimensions for 9:16 aspect ratio
            const CANVAS_WIDTH = 720;
            const CANVAS_HEIGHT = 1280;
            const BASE_PADDING = 60; // Base padding from canvas edges

            let debounceTimer; // For debouncing text input
            let uploadedBgImage = null; // Store the uploaded image object

            // Function to debounce calls
            const debounce = (func, delay) => {
                return function (...args) {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => func.apply(this, args), delay);
                };
            };

            // Initially disable the generate button, enable after fonts load
            generateBtn.disabled = true;
            generateBtn.textContent = '生成图片 (加载中...)';

            // Wait for all Google Fonts to be loaded
            document.fonts.ready.then(() => {
                generateBtn.disabled = false;
                generateBtn.textContent = '生成图片';
                // Trigger initial image generation once fonts are loaded
                generateImage(); // Initial render

                // Attach event listeners for real-time updates
                inputText.addEventListener('input', debounce(generateImage, 500)); // Debounce text input
                fontSelect.addEventListener('change', generateImage);
                backgroundSelect.addEventListener('change', () => {
                    // Show/hide custom upload container based on selection
                    if (backgroundSelect.value === 'custom') {
                        customBgUploadContainer.classList.remove('hidden');
                    } else {
                        customBgUploadContainer.classList.add('hidden');
                        uploadedBgImage = null; // Clear uploaded image if switching away
                    }
                    generateImage();
                });
                customBgUpload.addEventListener('change', handleImageUpload); // Handle image upload
                textColorInput.addEventListener('input', generateImage);
                fontSizeInput.addEventListener('input', generateImage);
                charSpacingInput.addEventListener('input', generateImage); // New listener
                lineSpacingFactorInput.addEventListener('input', generateImage); // New listener
                textAlignmentSelect.addEventListener('change', generateImage);
                topOffsetInput.addEventListener('input', generateImage);
                randomnessIntensityInput.addEventListener('input', generateImage);
                lineSkewAngleInput.addEventListener('input', generateImage);
                verticalWritingCheckbox.addEventListener('change', () => {
                    // Toggle vertical writing options visibility and enable/disable horizontal alignment
                    if (verticalWritingCheckbox.checked) {
                        verticalDirectionOptions.style.display = 'block';
                        textAlignmentSelect.disabled = true;
                        textAlignmentSelect.value = 'left'; // Reset to left if user unchecks later
                    } else {
                        verticalDirectionOptions.style.display = 'none';
                        textAlignmentSelect.disabled = false;
                    }
                    generateImage(); // Trigger update immediately on checkbox change
                });
                verticalDirectionSelect.addEventListener('change', generateImage);

            }).catch(error => {
                console.error("字体加载失败:", error);
                showMessage("字体加载失败，请刷新页面重试。");
                generateBtn.textContent = '字体加载失败';
            });

            // Handle custom background image upload
            function handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) {
                    uploadedBgImage = null; // Clear if no file selected
                    generateImage(); // Regenerate with current background
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedBgImage = img; // Store the loaded image
                        generateImage(); // Regenerate with new custom background
                    };
                    img.onerror = () => {
                        showMessage('图片加载失败，请尝试其他图片。');
                        uploadedBgImage = null;
                        generateImage(); // Fallback
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    showMessage('文件读取失败，请重试。');
                    uploadedBgImage = null;
                    generateImage(); // Fallback
                };
                reader.readAsDataURL(file);
            }


            // Update slider value displays
            fontSizeInput.addEventListener('input', () => {
                fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
            });
            charSpacingInput.addEventListener('input', () => {
                charSpacingValueSpan.textContent = `${charSpacingInput.value}px`;
            });
            lineSpacingFactorInput.addEventListener('input', () => {
                lineSpacingFactorValueSpan.textContent = `${lineSpacingFactorInput.value}%`;
            });
            topOffsetInput.addEventListener('input', () => {
                topOffsetValueSpan.textContent = `${topOffsetInput.value}%`;
            });
            randomnessIntensityInput.addEventListener('input', () => {
                randomnessIntensityValueSpan.textContent = randomnessIntensityInput.value;
            });
            lineSkewAngleInput.addEventListener('input', () => {
                lineSkewAngleValueSpan.textContent = `${lineSkewAngleInput.value}°`;
            });

            // Show message box temporarily
            function showMessage(message) {
                messageBox.textContent = message;
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 3000); // Hide after 3 seconds
            }

            // Function to draw handwritten text on canvas
            function drawHandwrittenText(context, text, font, textColor, fontSize, startX, startY, maxWidth, lineHeight, alignment, randomnessIntensity, lineSkewAngle, isVertical, verticalDirection, charSpacing, lineSpacingFactor) {
                context.fillStyle = textColor;
                context.font = `${fontSize}px "${font}"`;
                context.textBaseline = 'top';

                const textLines = text.split('\n'); // Preserve user's newlines

                if (isVertical) {
                    // Vertical writing mode: characters stack, columns move left-to-right or right-to-left
                    let currentColumnX;
                    const effectiveLineHeight = fontSize * (lineSpacingFactor / 100); // Effective line height
                    const baseColumnAdvance = effectiveLineHeight + charSpacing; // Column advance now depends on line spacing
                    const charVerticalSpacing = effectiveLineHeight;


                    // Initialize starting X for columns based on vertical direction
                    if (verticalDirection === 'rtl') {
                        currentColumnX = CANVAS_WIDTH - BASE_PADDING - fontSize; // Start from right
                    } else { // ltr
                        currentColumnX = startX; // Start from left
                    }

                    let currentColumnY = startY;

                    for (let lineIndex = 0; lineIndex < textLines.length; lineIndex++) {
                        const lineContent = textLines[lineIndex];

                        // For each user-defined line (separated by \n), start a new column in vertical mode
                        // Except for the very first line if it fits.
                        // Also, if the current column is full, start a new one.
                        // Skip starting a new column if the previous line was empty and this one is too.
                        if (lineIndex > 0 || (currentColumnY > startY && lineContent.length > 0)) {
                            if (verticalDirection === 'rtl') {
                                currentColumnX -= (baseColumnAdvance + (Math.random() * randomnessIntensity * 1.5));
                            } else {
                                currentColumnX += (baseColumnAdvance + (Math.random() * randomnessIntensity * 1.5));
                            }
                            currentColumnY = startY; // Reset Y for new column

                            // Check if new column goes out of bounds horizontally
                            if (verticalDirection === 'rtl' && currentColumnX < BASE_PADDING - (fontSize / 2)) { // Allow a bit of overflow to avoid abrupt cutoff
                                showMessage('垂直模式文字超出图片左侧边界，请减少内容或调整设置。');
                                return; // Stop drawing
                            }
                            if (verticalDirection === 'ltr' && currentColumnX + fontSize > CANVAS_WIDTH - BASE_PADDING + (fontSize / 2)) {
                                showMessage('垂直模式文字超出图片右侧边界，请减少内容或调整设置。');
                                return; // Stop drawing
                            }
                        }

                        for (let i = 0; i < lineContent.length; i++) {
                            const char = lineContent[i];

                            // Skip empty characters that might result from extra spaces at line ends/starts
                            // This helps in clean vertical layout, assuming spaces between words are often handled by column advance
                            if (char === ' ' && (i === lineContent.length - 1 || i === 0)) {
                                continue;
                            }

                            // Apply character jitter (x, y) relative to current position
                            const charXJitter = (Math.random() - 0.5) * randomnessIntensity;
                            const charYJitter = (Math.random() - 0.5) * randomnessIntensity;

                            context.save();
                            context.translate(currentColumnX + charXJitter, currentColumnY + charYJitter);

                            // Apply random rotation to each character
                            const randomCharSkewRad = ((Math.random() - 0.5) * lineSkewAngle) * Math.PI / 180;
                            context.rotate(randomCharSkewRad);

                            // For vertical text, characters are typically drawn centered horizontally in their "column slot"
                            context.textAlign = 'center'; // Center the character around the current translation point
                            context.fillText(char, 0, 0); // Draw at (0,0) relative to translated origin

                            context.restore();

                            currentColumnY += charVerticalSpacing + (Math.random() * randomnessIntensity * 0.5); // Advance Y

                            // If current character exceeds column height, move to next column
                            if (currentColumnY + fontSize > CANVAS_HEIGHT - BASE_PADDING) {
                                currentColumnY = startY; // Reset Y for new column
                                if (verticalDirection === 'rtl') {
                                    currentColumnX -= (baseColumnAdvance + (Math.random() * randomnessIntensity * 1.5));
                                } else {
                                    currentColumnX += (baseColumnAdvance + (Math.random() * randomnessIntensity * 1.5));
                                }

                                // Check again if new column goes out of bounds horizontally
                                if (verticalDirection === 'rtl' && currentColumnX < BASE_PADDING - (fontSize / 2)) {
                                    showMessage('垂直模式文字超出图片左侧边界，请减少内容或调整设置。');
                                    return; // Stop drawing
                                }
                                if (verticalDirection === 'ltr' && currentColumnX + fontSize > CANVAS_WIDTH - BASE_PADDING + (fontSize / 2)) {
                                    showMessage('垂直模式文字超出图片右侧边界，请减少内容或调整设置。');
                                    return; // Stop drawing
                                }
                            }
                        }
                    }

                } else {
                    // Horizontal writing mode
                    let currentY = startY;
                    const effectiveLineHeight = fontSize * (lineSpacingFactor / 100);

                    for (let i = 0; i < textLines.length; i++) {
                        const line = textLines[i];

                        // Apply random Y offset for the entire line
                        const lineYJitter = (Math.random() - 0.5) * randomnessIntensity;
                        let lineActualY = currentY + lineYJitter;

                        // Apply random line skew
                        const randomLineSkewRad = ((Math.random() - 0.5) * lineSkewAngle) * Math.PI / 180;

                        context.save(); // Save the current state of the canvas context

                        let translationX;
                        // Calculate the estimated width of the entire line for centering/right-aligning
                        let estimatedLineWidth = 0;
                        for (let k = 0; k < line.length; k++) {
                            estimatedLineWidth += context.measureText(line[k]).width;
                        }
                        // Add character spacing to the estimated width
                        estimatedLineWidth += (line.length - 1) * charSpacing;


                        if (alignment === 'center') {
                            translationX = (CANVAS_WIDTH / 2) - (estimatedLineWidth / 2);
                        } else if (alignment === 'right') {
                            translationX = CANVAS_WIDTH - BASE_PADDING - estimatedLineWidth;
                        } else { // default 'left'
                            translationX = startX;
                        }

                        // Ensure text does not go outside padding if estimatedLineWidth is very large
                        translationX = Math.max(BASE_PADDING, translationX);
                        if (translationX + estimatedLineWidth > CANVAS_WIDTH - BASE_PADDING) {
                            translationX = CANVAS_WIDTH - BASE_PADDING - estimatedLineWidth;
                        }


                        context.translate(translationX, lineActualY);
                        context.rotate(randomLineSkewRad); // Apply rotation after translation

                        let charDrawX = 0; // X position relative to current translation origin

                        // Draw characters in the line
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            const charWidth = context.measureText(char).width;

                            // Apply character jitter (relative to the current rotated line's local coordinates)
                            const charXJitter = (Math.random() - 0.5) * randomnessIntensity;
                            const charYJitter = (Math.random() - 0.5) * randomnessIntensity;

                            context.fillText(char, charDrawX + charXJitter, charYJitter);
                            charDrawX += charWidth + charSpacing; // Advance X for next character, including char spacing
                        }

                        context.restore(); // Restore to previous canvas state

                        currentY += effectiveLineHeight + (Math.random() * randomnessIntensity * 0.5); // Advance Y for next line, add random line spacing

                        // Check if text has gone too far down the page
                        if (currentY + fontSize > (CANVAS_HEIGHT - BASE_PADDING)) {
                            showMessage('文字内容过多，可能超出图片范围。');
                            break; // Stop drawing if out of bounds
                        }
                    }
                }
            }


            // Generate Image function
            async function generateImage() {
                const text = inputText.value; // Get raw text, don't trim to preserve spaces
                loadingIndicator.classList.remove('hidden');
                placeholderText.classList.add('hidden'); // Hide placeholder when generating
                outputImage.style.display = 'none'; // Hide old image

                const selectedFont = fontSelect.value;
                const selectedBackground = backgroundSelect.value;
                const selectedTextColor = textColorInput.value;
                const fontSize = parseInt(fontSizeInput.value);
                const charSpacing = parseInt(charSpacingInput.value); // New
                const lineSpacingFactor = parseInt(lineSpacingFactorInput.value); // New

                const textAlignment = textAlignmentSelect.value;
                const topOffsetPercentage = parseInt(topOffsetInput.value);
                const topOffsetPixels = (topOffsetPercentage / 100) * CANVAS_HEIGHT;

                const randomnessIntensity = parseInt(randomnessIntensityInput.value);
                const lineSkewAngle = parseInt(lineSkewAngleInput.value);
                const isVerticalWriting = verticalWritingCheckbox.checked;
                const verticalDirection = verticalDirectionSelect.value;

                outputCanvas.width = CANVAS_WIDTH;
                outputCanvas.height = CANVAS_HEIGHT;

                try {
                    // Draw background
                    if (selectedBackground === 'notebook') {
                        ctx.fillStyle = '#F0F8FF';
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

                        ctx.strokeStyle = '#ADD8E6';
                        ctx.lineWidth = 1;
                        // Use effective line height for notebook lines
                        const notebookLineHeight = fontSize * (lineSpacingFactor / 100);
                        for (let i = BASE_PADDING + topOffsetPixels; i < outputCanvas.height - BASE_PADDING; i += notebookLineHeight) {
                            ctx.beginPath();
                            ctx.moveTo(BASE_PADDING, i);
                            ctx.lineTo(outputCanvas.width - BASE_PADDING, i);
                            ctx.stroke();
                        }
                        ctx.strokeStyle = '#FF6347';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(BASE_PADDING + 20, 0);
                        ctx.lineTo(BASE_PADDING + 20, outputCanvas.height);
                        ctx.stroke();
                    } else if (selectedBackground === 'parchment-texture') {
                        drawParchmentTexture(ctx, outputCanvas.width, outputCanvas.height);
                    } else if (selectedBackground === 'vintage-paper') {
                        drawVintagePaperTexture(ctx, outputCanvas.width, outputCanvas.height);
                    } else if (selectedBackground === 'custom') { // Handle custom background
                        if (uploadedBgImage) {
                            // Draw image to cover the canvas
                            const hRatio = CANVAS_WIDTH / uploadedBgImage.width;
                            const vRatio = CANVAS_HEIGHT / uploadedBgImage.height;
                            const ratio = Math.max(hRatio, vRatio); // Use max to ensure cover
                            const sWidth = uploadedBgImage.width * ratio;
                            const sHeight = uploadedBgImage.height * ratio;
                            const sx = (CANVAS_WIDTH - sWidth) / 2;
                            const sy = (CANVAS_HEIGHT - sHeight) / 2;
                            ctx.drawImage(uploadedBgImage, sx, sy, sWidth, sHeight);
                        } else {
                            // If custom selected but no image uploaded, fallback to white and show message
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                            showMessage('请上传自定义背景图片！');
                        }
                    } else { // white
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                    }

                    // Only draw text if inputText is not empty after trimming
                    if (text.trim() === '') {
                        placeholderText.classList.remove('hidden'); // Show placeholder if text is empty
                        outputImage.style.display = 'none'; // Hide generated image
                        downloadBtn.classList.add('hidden');
                        copyBtn.classList.add('hidden');
                    } else {
                        drawHandwrittenText(
                            ctx,
                            text,
                            selectedFont,
                            selectedTextColor,
                            fontSize,
                            BASE_PADDING,
                            BASE_PADDING + topOffsetPixels,
                            CANVAS_WIDTH - BASE_PADDING * 2,
                            fontSize * 1.5, // Base line height passed, then modified by lineSpacingFactor inside
                            textAlignment,
                            randomnessIntensity,
                            lineSkewAngle,
                            isVerticalWriting,
                            verticalDirection,
                            charSpacing, // New
                            lineSpacingFactor // New
                        );

                        // Convert Canvas content to image
                        const imageDataUrl = outputCanvas.toDataURL('image/png');
                        outputImage.src = imageDataUrl;
                        outputImage.style.display = 'block';
                        downloadBtn.href = imageDataUrl;
                        downloadBtn.classList.remove('hidden');
                        copyBtn.classList.remove('hidden');
                    }

                } catch (error) {
                    console.error("生成图片时发生错误:", error);
                    showMessage("生成图片时发生错误，请检查输入或刷新页面。");
                    // Ensure placeholder is shown if an error occurs during drawing
                    placeholderText.classList.remove('hidden');
                    outputImage.style.display = 'none';
                    downloadBtn.classList.add('hidden');
                    copyBtn.classList.add('hidden');
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }

            // Copy image link functionality
            copyBtn.addEventListener('click', () => {
                const imageDataUrl = outputImage.src;
                if (imageDataUrl) {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = imageDataUrl;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        document.execCommand('copy');
                        showMessage('图片链接已复制到剪贴板！');
                    } catch (err) {
                        showMessage('复制失败，请手动复制。');
                    }
                    document.body.removeChild(tempInput);
                } else {
                    showMessage('请先生成图片！');
                }
            });

            // Initial display for sliders
            fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
            charSpacingValueSpan.textContent = `${charSpacingInput.value}px`; // New initial display
            lineSpacingFactorValueSpan.textContent = `${lineSpacingFactorInput.value}%`; // New initial display
            topOffsetValueSpan.textContent = `${topOffsetInput.value}%`;
            randomnessIntensityValueSpan.textContent = randomnessIntensityInput.value;
            lineSkewAngleValueSpan.textContent = `${lineSkewAngleInput.value}°`;

            // Canvas background drawing functions (retained from previous versions)
            function drawParchmentTexture(context, width, height) {
                context.fillStyle = '#F5DEB3';
                context.fillRect(0, 0, width, height);
                for (let i = 0; i < 8000; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 0.6 + 0.1;
                    const alpha = Math.random() * 0.2 + 0.1;
                    const color = Math.random() < 0.5 ? 'rgba(0,0,0,' : 'rgba(255,255,255,';
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = color + alpha + ')';
                    context.fill();
                }
            }

            function drawVintagePaperTexture(context, width, height) {
                context.fillStyle = '#FDF6E3';
                context.fillRect(0, 0, width, height);
                for (let i = 0; i < 80; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 40 + 15;
                    const alpha = Math.random() * 0.12 + 0.08;
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = `rgba(139,69,19,${alpha})`;
                    context.fill();
                }
                context.strokeStyle = `rgba(139,69,19,0.05)`;
                context.lineWidth = 0.8;
                for (let i = 0; i < 30; i++) {
                    context.beginPath();
                    context.moveTo(Math.random() * width, Math.random() * height);
                    context.lineTo(Math.random() * width, Math.random() * height);
                    context.stroke();
                }
            }
        });
    </script>
</body>

</html>