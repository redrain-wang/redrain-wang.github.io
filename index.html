<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–‡å­—å›¾ç‰‡ç”Ÿæˆå™¨</title>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Google Fonts Import for UI and Handwriting Fonts */
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Smiley+Sans&family=LXGW+WenKai+Lite&family=Ma+Shan+Zheng&family=Liu+Jian+Mao+Cao&family=Long+Cang&family=Noto+Sans+SC:wght@300;400;500;700&family=Noto+Serif+SC:wght@300;400;500;700&family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            /* ä½¿ç”¨Interä½œä¸ºUIç•Œé¢çš„é»˜è®¤å­—ä½“ */
        }

        /* Custom Handwriting Font Styles */
        .font-zcool-kuaile {
            font-family: 'ZCOOL KuaiLe', cursive;
        }

        .font-smiley-sans {
            font-family: 'Smiley Sans', sans-serif;
        }

        .font-lxgw-wenkai {
            font-family: 'LXGW WenKai Lite', cursive;
            /* Using Lite version for broader compatibility */
        }

        .font-ma-shan-zheng {
            font-family: 'Ma Shan Zheng', cursive;
        }

        .font-liu-jian-mao-cao {
            font-family: 'Liu Jian Mao Cao', cursive;
        }

        .font-long-cang {
            font-family: 'Long Cang', cursive;
        }

        /* New Noto Sans SC Styles */
        .font-noto-sans-sc {
            font-family: 'Noto Sans SC', sans-serif;
        }

        /* New Noto Serif SC Styles */
        .font-noto-serif-sc {
            font-family: 'Noto Serif SC', serif;
        }

        /* Hide Canvas, only show Image */
        #outputCanvas {
            display: none;
        }

        /* Custom Slider Styles */
        input[type='range']::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            /* purple-500 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
            /* purple-500 with opacity */
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }

        input[type='range']::-webkit-slider-thumb:hover {
            background: #7c3aed;
            /* purple-600 */
        }

        input[type='range']::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }

        input[type='range']::-moz-range-thumb:hover {
            background: #7c3aed;
        }
    </style>
</head>

<body
    class="bg-gradient-to-br from-purple-100 via-pink-100 to-blue-200 min-h-screen flex items-center justify-center p-6 text-gray-800">

    <div
        class="bg-white p-10 rounded-3xl shadow-2xl max-w-5xl w-full border border-gray-100 transform transition-all duration-300 hover:scale-[1.005]">
        <h1
            class="text-5xl font-extrabold text-center text-purple-700 mb-10 tracking-tight flex items-center justify-center space-x-3">
            <svg class="w-10 h-10 text-pink-500" fill="currentColor" viewBox="0 0 20 20"
                xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd"
                    d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828zM4 12a2 2 0 012-2h.01a.75.75 0 100-1.5H6a3.5 3.5 0 00-3.5 3.5v1.5a.75.75 0 001.5 0V12zM15 15a.75.75 0 00-.75.75v1.5a.75.75 0 01-.75.75H4a2 2 0 01-2-2v-1.5a.75.75 0 00-1.5 0v1.5a3.5 3.5 0 003.5 3.5h9.5a3.5 3.5 0 003.5-3.5v-1.5a.75.75 0 00-1.5 0V15z"
                    clip-rule="evenodd"></path>
            </svg>
            <span>æ–‡å­—å›¾ç‰‡ç”Ÿæˆå™¨</span>
        </h1>

        <div class="grid md:grid-cols-2 gap-10">
            <!-- è®¾ç½®è¡¨å• -->
            <div class="space-y-7">
                <div>
                    <label for="inputText" class="block text-lg font-semibold text-gray-700 mb-2">è¾“å…¥æ–‡å­—:</label>
                    <textarea id="inputText"
                        class="w-full p-4 border border-gray-300 rounded-xl focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base h-40 resize-y shadow-sm hover:shadow-md"
                        placeholder="åœ¨è¿™é‡Œè¾“å…¥ä½ æƒ³è¦ç”Ÿæˆæ‰‹å†™ä½“çš„æ–‡å­—...ï¼ˆå›è½¦å’Œç©ºæ ¼ä¼šè¢«ä¿ç•™ï¼‰"></textarea>
                </div>

                <div>
                    <label for="fontSelect" class="block text-lg font-semibold text-gray-700 mb-2">é€‰æ‹©å­—ä½“:</label>
                    <select id="fontSelect"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="LXGW WenKai Lite">éœé¹œæ–‡æ¥· (LXGW WenKai Lite)</option>
                        <option value="ZCOOL KuaiLe">ç«™é…·å¿«ä¹ä½“ (ZCOOL KuaiLe)</option>
                        <option value="Smiley Sans">å¾—æ„é»‘ (Smiley Sans)</option>
                        <option value="Ma Shan Zheng">é©¬å–„æ”¿ (Ma Shan Zheng)</option>
                        <option value="Liu Jian Mao Cao">åˆ˜æ±Ÿæ¯›è‰ (Liu Jian Mao Cao)</option>
                        <option value="Long Cang">é¾™è—ä½“ (Long Cang)</option>
                        <option value="Noto Sans SC">æ€æºé»‘ä½“ (Noto Sans SC)</option> <!-- New font option -->
                        <option value="Noto Serif SC">æ€æºå®‹ä½“ (Noto Serif SC)</option> <!-- New font option -->
                    </select>
                </div>

                <div>
                    <label for="backgroundSelect" class="block text-lg font-semibold text-gray-700 mb-2">é€‰æ‹©èƒŒæ™¯:</label>
                    <select id="backgroundSelect"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="notebook">ç¬”è®°æœ¬</option>
                        <option value="parchment-texture">ç¾Šçš®çº¸çº¹ç†</option>
                        <option value="vintage-paper">å¤å¤çº¸å¼ </option>
                        <option value="white">çº¯ç™½</option>
                        <option value="custom">è‡ªå®šä¹‰å›¾ç‰‡</option>
                    </select>
                </div>

                <!-- è‡ªå®šä¹‰èƒŒæ™¯ä¸Šä¼  -->
                <div id="customBgUploadContainer" class="hidden">
                    <label for="customBgUpload"
                        class="block text-lg font-semibold text-gray-700 mb-2">ä¸Šä¼ è‡ªå®šä¹‰èƒŒæ™¯å›¾ç‰‡:</label>
                    <input type="file" id="customBgUpload" accept="image/*"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md cursor-pointer">
                    <span class="block text-sm text-gray-600 mt-1">æ”¯æŒ JPG, PNG ç­‰æ ¼å¼ã€‚å›¾ç‰‡å°†è‡ªåŠ¨ç¼©æ”¾ä»¥è¦†ç›–æ•´ä¸ªèƒŒæ™¯ã€‚</span>
                </div>


                <div>
                    <label for="textColor" class="block text-lg font-semibold text-gray-700 mb-2">æ–‡å­—é¢œè‰²:</label>
                    <input type="color" id="textColor" value="#333333"
                        class="w-full h-12 border border-gray-300 rounded-xl cursor-pointer focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out shadow-sm hover:shadow-md">
                </div>

                <div>
                    <label for="fontSize" class="block text-lg font-semibold text-gray-700 mb-2">å­—ä½“å¤§å°:</label>
                    <input type="range" id="fontSize" min="20" max="80" value="40"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="fontSizeValue" class="block text-sm text-gray-600 mt-2 text-right">40px</span>
                </div>

                <!-- æ–°å¢å­—é—´è·å’Œè¡Œé—´è· -->
                <div>
                    <label for="charSpacing" class="block text-lg font-semibold text-gray-700 mb-2">å­—é—´è·:</label>
                    <input type="range" id="charSpacing" min="-10" max="20" value="0"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="charSpacingValue" class="block text-sm text-gray-600 mt-2 text-right">0px</span>
                    <span class="block text-sm text-gray-600 mt-1">è°ƒæ•´å­—ç¬¦ä¹‹é—´çš„é¢å¤–ç©ºé—´ã€‚</span>
                </div>

                <div>
                    <label for="lineSpacingFactor" class="block text-lg font-semibold text-gray-700 mb-2">è¡Œé—´è·:</label>
                    <input type="range" id="lineSpacingFactor" min="80" max="200" value="100"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="lineSpacingFactorValue" class="block text-sm text-gray-600 mt-2 text-right">100%</span>
                    <span class="block text-sm text-gray-600 mt-1">è°ƒæ•´è¡Œä¸è¡Œä¹‹é—´çš„é¢å¤–ç©ºé—´ (100% ä¸ºé»˜è®¤)ã€‚</span>
                </div>


                <!-- æ–‡å­—ä½ç½®è®¾ç½® -->
                <div>
                    <label for="textAlignment" class="block text-lg font-semibold text-gray-700 mb-2">æ–‡å­—ä½ç½® (æ°´å¹³):</label>
                    <select id="textAlignment"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="left">å±…å·¦</option>
                        <option value="center">å±…ä¸­</option>
                        <option value="right">å±…å³</option>
                    </select>
                </div>

                <div>
                    <label for="topOffset" class="block text-lg font-semibold text-gray-700 mb-2">è·ç¦»é¡¶éƒ¨ (%):</label>
                    <input type="range" id="topOffset" min="0" max="50" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="topOffsetValue" class="block text-sm text-gray-600 mt-2 text-right">5%</span>
                    <span class="block text-sm text-gray-600 mt-1">è®¾ç½®æ–‡å­—å†…å®¹å—è·ç¦»å›¾ç‰‡é¡¶éƒ¨çš„ç™¾åˆ†æ¯”ã€‚</span>
                </div>

                <!-- éšæœºæŠ–åŠ¨å¼ºåº¦ -->
                <div>
                    <label for="randomnessIntensity"
                        class="block text-lg font-semibold text-gray-700 mb-2">éšæœºæŠ–åŠ¨å¼ºåº¦:</label>
                    <input type="range" id="randomnessIntensity" min="0" max="25" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="randomnessIntensityValue" class="block text-sm text-gray-600 mt-2 text-right">5</span>
                    <span class="block text-sm text-gray-600 mt-1">å¢åŠ æ–‡å­—çš„éšæœºåç§»ï¼Œæ¨¡æ‹Ÿæ‰‹å†™ä¸è§„åˆ™æ„Ÿï¼ˆ0ä¸ºæ— æŠ–åŠ¨ï¼‰ã€‚</span>
                </div>

                <!-- éšæœºå€¾æ–œè§’åº¦ -->
                <div>
                    <label for="lineSkewAngle" class="block text-lg font-semibold text-gray-700 mb-2">éšæœºå€¾æ–œè§’åº¦
                        (åº¦):</label>
                    <input type="range" id="lineSkewAngle" min="0" max="15" value="0"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="lineSkewAngleValue" class="block text-sm text-gray-600 mt-2 text-right">0Â°</span>
                    <span class="block text-sm text-gray-600 mt-1">è®¾ç½®æ¯è¡Œ/å­—ç¬¦çš„éšæœºå€¾æ–œèŒƒå›´ï¼ˆ0ä¸ºæ— å€¾æ–œï¼‰ã€‚</span>
                </div>

                <!-- å‚ç›´ä¹¦å†™æ¨¡å¼ -->
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="verticalWriting"
                        class="h-5 w-5 text-purple-600 rounded focus:ring-purple-500 cursor-pointer">
                    <label for="verticalWriting" class="text-lg font-semibold text-gray-700">å‚ç›´ä¹¦å†™æ¨¡å¼</label>
                </div>

                <!-- å‚ç›´ä¹¦å†™æ–¹å‘é€‰é¡¹ -->
                <div class="space-y-3" id="verticalDirectionOptions" style="display: none;"> <!-- åˆå§‹éšè— -->
                    <label for="verticalDirection"
                        class="block text-lg font-semibold text-gray-700 mb-2">å‚ç›´ä¹¦å†™æ–¹å‘:</label>
                    <select id="verticalDirection"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="ltr">ä»å·¦åˆ°å³</option>
                        <option value="rtl">ä»å³åˆ°å·¦</option>
                    </select>
                </div>

                <!-- ç”ŸæˆæŒ‰é’® - å­—ä½“åŠ è½½åå¯ç”¨ -->
                <button id="generateBtn"
                    class="w-full bg-gradient-to-r from-purple-600 to-pink-500 text-white py-4 rounded-xl text-2xl font-bold hover:from-purple-700 hover:to-pink-600 focus:outline-none focus:ring-6 focus:ring-purple-400 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95"
                    disabled>ç”Ÿæˆå›¾ç‰‡ (åŠ è½½ä¸­...)</button>

                <div id="loadingIndicator"
                    class="hidden text-center text-purple-600 font-semibold text-lg mt-4 animate-pulse">
                    æ­£åœ¨ç”Ÿæˆå›¾ç‰‡ï¼Œè¯·ç¨å€™...
                </div>
            </div>

            <!-- å›¾ç‰‡é¢„è§ˆåŒº -->
            <div
                class="bg-gray-100 p-8 rounded-2xl shadow-inner flex items-center justify-center min-h-[400px] border border-gray-200 relative overflow-hidden">
                <img id="outputImage" class="max-w-full h-auto rounded-lg shadow-xl" alt="ç”Ÿæˆçš„å›¾ç‰‡"
                    style="max-height: 500px; display: none;">
                <canvas id="outputCanvas" class="border border-gray-300 rounded-lg shadow-md"></canvas>
                <p id="placeholderText" class="text-gray-500 text-center text-xl font-medium">è¾“å…¥æ–‡å­—å¹¶è°ƒæ•´è®¾ç½®ä»¥ç”Ÿæˆå›¾ç‰‡</p>
            </div>
        </div>

        <!-- åº•éƒ¨æ“ä½œæŒ‰é’® -->
        <div class="mt-10 flex justify-center space-x-6">
            <a id="downloadBtn" download="generated_text_image.png"
                class="hidden bg-gradient-to-r from-green-500 to-teal-500 text-white py-3 px-8 rounded-xl text-lg font-semibold hover:from-green-600 hover:to-teal-600 focus:outline-none focus:ring-6 focus:ring-green-300 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95">ä¸‹è½½å›¾ç‰‡</a>
            <button id="copyBtn"
                class="hidden bg-gradient-to-r from-blue-500 to-cyan-500 text-white py-3 px-8 rounded-xl text-lg font-semibold hover:from-blue-600 hover:to-cyan-600 focus:outline-none focus:ring-6 focus:ring-blue-300 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95">å¤åˆ¶å›¾ç‰‡é“¾æ¥</button>
            <div id="messageBox"
                class="fixed bottom-8 right-8 bg-black bg-opacity-80 text-white py-3 px-6 rounded-lg shadow-xl text-sm hidden z-50">
            </div>
        </div>

        <!-- Mobile Save Tip -->
        <div id="mobileSaveTip"
            class="hidden text-center mt-8 p-4 bg-yellow-50 border border-yellow-200 text-yellow-800 rounded-lg shadow-sm">
            <p class="font-semibold text-lg mb-2">ğŸ“¢ æ‰‹æœºç«¯ä¿å­˜æç¤ºï¼š</p>
            <p class="text-base">
                ç”±äºç³»ç»Ÿé™åˆ¶ï¼Œç½‘é¡µæ— æ³•ç›´æ¥ä¿å­˜å›¾ç‰‡åˆ°ç›¸å†Œã€‚
                è¯·åœ¨ä¸Šæ–¹ç”Ÿæˆçš„å›¾ç‰‡ä¸Š **é•¿æŒ‰ï¼ˆæˆ–é‡æŒ‰ï¼‰**ï¼Œç„¶åé€‰æ‹©èœå•ä¸­çš„ **â€œä¿å­˜å›¾ç‰‡â€** æˆ– **â€œæ·»åŠ åˆ°ç…§ç‰‡â€** å³å¯ä¿å­˜åˆ°æ‚¨çš„è®¾å¤‡ç›¸å†Œã€‚
            </p>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get all necessary DOM elements
            const inputText = document.getElementById('inputText');
            const fontSelect = document.getElementById('fontSelect');
            const backgroundSelect = document.getElementById('backgroundSelect');
            const customBgUploadContainer = document.getElementById('customBgUploadContainer');
            const customBgUpload = document.getElementById('customBgUpload');
            const textColorInput = document.getElementById('textColor');
            const fontSizeInput = document.getElementById('fontSize');
            const fontSizeValueSpan = document.getElementById('fontSizeValue');
            const charSpacingInput = document.getElementById('charSpacing');
            const charSpacingValueSpan = document.getElementById('charSpacingValue');
            const lineSpacingFactorInput = document.getElementById('lineSpacingFactor');
            const lineSpacingFactorValueSpan = document.getElementById('lineSpacingFactorValue');
            const textAlignmentSelect = document.getElementById('textAlignment');
            const topOffsetInput = document.getElementById('topOffset');
            const topOffsetValueSpan = document.getElementById('topOffsetValue');
            const randomnessIntensityInput = document.getElementById('randomnessIntensity');
            const randomnessIntensityValueSpan = document.getElementById('randomnessIntensityValue');
            const lineSkewAngleInput = document.getElementById('lineSkewAngle');
            const lineSkewAngleValueSpan = document.getElementById('lineSkewAngleValue');
            const verticalWritingCheckbox = document.getElementById('verticalWriting');
            const verticalDirectionOptions = document.getElementById('verticalDirectionOptions');
            const verticalDirectionSelect = document.getElementById('verticalDirection');
            const generateBtn = document.getElementById('generateBtn');
            const outputImage = document.getElementById('outputImage');
            const outputCanvas = document.getElementById('outputCanvas');
            const downloadBtn = document.getElementById('downloadBtn');
            const copyBtn = document.getElementById('copyBtn');
            const placeholderText = document.getElementById('placeholderText');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const messageBox = document.getElementById('messageBox');
            const mobileSaveTip = document.getElementById('mobileSaveTip');
            const ctx = outputCanvas.getContext('2d');

            // Fixed Canvas dimensions for 9:16 aspect ratio
            const CANVAS_WIDTH = 720;
            const CANVAS_HEIGHT = 1280;
            const BASE_PADDING = 60; // Base padding from canvas edges

            let debounceTimer; // For debouncing text input
            let uploadedBgImage = null; // Store the uploaded image object

            // Function to debounce calls
            const debounce = (func, delay) => {
                return function (...args) {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => func.apply(this, args), delay);
                };
            };

            // Initially disable the generate button, enable after fonts load
            generateBtn.disabled = true;
            generateBtn.textContent = 'ç”Ÿæˆå›¾ç‰‡ (åŠ è½½ä¸­...)';

            // Wait for all Google Fonts to be loaded
            document.fonts.ready.then(() => {
                generateBtn.disabled = false;
                generateBtn.textContent = 'ç”Ÿæˆå›¾ç‰‡';
                // Trigger initial image generation once fonts are loaded
                generateImage(); // Initial render

                // Attach event listeners for real-time updates
                inputText.addEventListener('input', debounce(generateImage, 500)); // Debounce text input
                fontSelect.addEventListener('change', generateImage);
                backgroundSelect.addEventListener('change', () => {
                    // Show/hide custom upload container based on selection
                    if (backgroundSelect.value === 'custom') {
                        customBgUploadContainer.classList.remove('hidden');
                    } else {
                        customBgUploadContainer.classList.add('hidden');
                        uploadedBgImage = null; // Clear uploaded image if switching away
                    }
                    generateImage();
                });
                customBgUpload.addEventListener('change', handleImageUpload); // Handle image upload
                textColorInput.addEventListener('input', generateImage);
                fontSizeInput.addEventListener('input', generateImage);
                charSpacingInput.addEventListener('input', generateImage);
                lineSpacingFactorInput.addEventListener('input', generateImage);
                textAlignmentSelect.addEventListener('change', generateImage);
                topOffsetInput.addEventListener('input', generateImage);
                randomnessIntensityInput.addEventListener('input', generateImage);
                lineSkewAngleInput.addEventListener('input', generateImage);
                verticalWritingCheckbox.addEventListener('change', () => {
                    // Toggle vertical writing options visibility and enable/disable horizontal alignment
                    if (verticalWritingCheckbox.checked) {
                        verticalDirectionOptions.style.display = 'block';
                        textAlignmentSelect.disabled = true;
                        textAlignmentSelect.value = 'left'; // Reset to left if user unchecks later
                    } else {
                        verticalDirectionOptions.style.display = 'none';
                        textAlignmentSelect.disabled = false;
                    }
                    generateImage(); // Trigger update immediately on checkbox change
                });
                verticalDirectionSelect.addEventListener('change', generateImage);

                // Show mobile save tip if on a mobile device
                if (/Mobi|Android/i.test(navigator.userAgent)) {
                    mobileSaveTip.classList.remove('hidden');
                }

            }).catch(error => {
                console.error("å­—ä½“åŠ è½½å¤±è´¥:", error);
                showMessage("å­—ä½“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚");
                generateBtn.textContent = 'å­—ä½“åŠ è½½å¤±è´¥';
            });

            // Handle custom background image upload
            function handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) {
                    uploadedBgImage = null; // Clear if no file selected
                    generateImage(); // Regenerate with current background
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Validate image dimensions (optional, but good for custom images)
                        // For 9:16 aspect ratio (720x1280), we can suggest minimal dimensions.
                        // Or just let it scale. For now, we'll let it scale and just draw.
                        uploadedBgImage = img; // Store the loaded image
                        generateImage(); // Regenerate with new custom background
                    };
                    img.onerror = () => {
                        showMessage('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·å°è¯•å…¶ä»–å›¾ç‰‡ã€‚');
                        uploadedBgImage = null;
                        generateImage(); // Fallback
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    showMessage('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
                    uploadedBgImage = null;
                    generateImage(); // Fallback
                };
                reader.readAsDataURL(file);
            }


            // Update slider value displays
            fontSizeInput.addEventListener('input', () => {
                fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
            });
            charSpacingInput.addEventListener('input', () => {
                charSpacingValueSpan.textContent = `${charSpacingInput.value}px`;
            });
            lineSpacingFactorInput.addEventListener('input', () => {
                lineSpacingFactorValueSpan.textContent = `${lineSpacingFactorInput.value}%`;
            });
            topOffsetInput.addEventListener('input', () => {
                topOffsetValueSpan.textContent = `${topOffsetInput.value}%`;
            });
            randomnessIntensityInput.addEventListener('input', () => {
                randomnessIntensityValueSpan.textContent = randomnessIntensityInput.value;
            });
            lineSkewAngleInput.addEventListener('input', () => {
                lineSkewAngleValueSpan.textContent = `${lineSkewAngleInput.value}Â°`;
            });

            // Show message box temporarily
            function showMessage(message) {
                messageBox.textContent = message;
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 3000); // Hide after 3 seconds
            }

            // Function to draw handwritten text on canvas
            function drawHandwrittenText(context, text, font, textColor, fontSize, startX, startY, maxWidth, lineHeight, alignment, randomnessIntensity, lineSkewAngle, isVertical, verticalDirection, charSpacing, lineSpacingFactor) {
                context.fillStyle = textColor;
                context.font = `${fontSize}px "${font}"`;
                context.textBaseline = 'top';

                const textLines = text.split('\n'); // Preserve user's newlines

                if (isVertical) {
                    // Vertical writing mode: characters stack, columns move left-to-right or right-to-left
                    let currentColumnX;
                    const effectiveCharHeight = fontSize * (lineSpacingFactor / 100); // Using lineSpacingFactor for vertical char spacing
                    const baseColumnAdvance = fontSize + charSpacing; // Column advance now depends on font size and char spacing

                    // Initialize starting X for columns based on vertical direction
                    if (verticalDirection === 'rtl') {
                        currentColumnX = CANVAS_WIDTH - BASE_PADDING - fontSize; // Start from right
                    } else { // ltr
                        currentColumnX = startX; // Start from left
                    }

                    let currentColumnY = startY;

                    for (let lineIndex = 0; lineIndex < textLines.length; lineIndex++) {
                        const lineContent = textLines[lineIndex];

                        // For each user-defined line (separated by \n), start a new column in vertical mode
                        // Except for the very first line if it fits.
                        // Also, if the current column is full, start a new one.
                        // If line is empty, just advance to next column/line.
                        if (lineIndex > 0 || (currentColumnY > startY && lineContent.length > 0)) { // Only advance column if it's not the first line AND not the first char of that line
                            if (verticalDirection === 'rtl') {
                                currentColumnX -= (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                            } else {
                                currentColumnX += (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                            }
                            currentColumnY = startY; // Reset Y for new column

                            // Check if new column goes out of bounds horizontally
                            if (verticalDirection === 'rtl' && currentColumnX < BASE_PADDING - (fontSize / 2)) {
                                showMessage('å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å·¦ä¾§è¾¹ç•Œï¼Œè¯·å‡å°‘å†…å®¹æˆ–è°ƒæ•´è®¾ç½®ã€‚');
                                return; // Stop drawing
                            }
                            if (verticalDirection === 'ltr' && currentColumnX + fontSize > CANVAS_WIDTH - BASE_PADDING + (fontSize / 2)) {
                                showMessage('å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å³ä¾§è¾¹ç•Œï¼Œè¯·å‡å°‘å†…å®¹æˆ–è°ƒæ•´è®¾ç½®ã€‚');
                                return; // Stop drawing
                            }
                        }

                        for (let i = 0; i < lineContent.length; i++) {
                            const char = lineContent[i];

                            // If char is a space, simply advance Y. Don't draw it.
                            if (char === ' ') {
                                currentColumnY += effectiveCharHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5;
                                continue;
                            }

                            // Apply character jitter (x, y) relative to current position
                            const charXJitter = (Math.random() - 0.5) * randomnessIntensity;
                            const charYJitter = (Math.random() - 0.5) * randomnessIntensity;

                            context.save();
                            context.translate(currentColumnX + charXJitter, currentColumnY + charYJitter);

                            // Apply random rotation to each character
                            const randomCharSkewRad = ((Math.random() - 0.5) * lineSkewAngle) * Math.PI / 180;
                            context.rotate(randomCharSkewRad);

                            context.textAlign = 'center'; // Center the character around the current translation point
                            context.fillText(char, 0, 0); // Draw at (0,0) relative to translated origin

                            context.restore();

                            currentColumnY += effectiveCharHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5; // Advance Y

                            // If current character exceeds column height, move to next column
                            if (currentColumnY + fontSize > CANVAS_HEIGHT - BASE_PADDING) {
                                currentColumnY = startY; // Reset Y for new column
                                if (verticalDirection === 'rtl') {
                                    currentColumnX -= (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                                } else {
                                    currentColumnX += (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                                }

                                // Check again if new column goes out of bounds horizontally
                                if (verticalDirection === 'rtl' && currentColumnX < BASE_PADDING - (fontSize / 2)) {
                                    showMessage('å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å·¦ä¾§è¾¹ç•Œï¼Œè¯·å‡å°‘å†…å®¹æˆ–è°ƒæ•´è®¾ç½®ã€‚');
                                    return; // Stop drawing
                                }
                                if (verticalDirection === 'ltr' && currentColumnX + fontSize > CANVAS_WIDTH - BASE_PADDING + (fontSize / 2)) {
                                    showMessage('å‚ç›´æ¨¡å¼æ–‡å­—è¶…å‡ºå›¾ç‰‡å³ä¾§è¾¹ç•Œï¼Œè¯·å‡å°‘å†…å®¹æˆ–è°ƒæ•´è®¾ç½®ã€‚');
                                    return; // Stop drawing
                                }
                            }
                        }
                    }

                } else {
                    // Horizontal writing mode
                    let currentY = startY;
                    const effectiveLineHeight = fontSize * (lineSpacingFactor / 100);

                    for (let i = 0; i < textLines.length; i++) {
                        const line = textLines[i];
                        if (line === '') { // Handle empty lines (just advance Y)
                            currentY += effectiveLineHeight;
                            continue;
                        }

                        // Apply random Y offset for the entire line
                        const lineYJitter = (Math.random() - 0.5) * randomnessIntensity;
                        let lineActualY = currentY + lineYJitter;

                        // Apply random line skew
                        const randomLineSkewRad = ((Math.random() - 0.5) * lineSkewAngle) * Math.PI / 180;

                        context.save(); // Save the current state of the canvas context

                        let translationX;
                        // Calculate the estimated width of the entire line for centering/right-aligning
                        let estimatedLineWidth = 0;
                        for (let k = 0; k < line.length; k++) {
                            estimatedLineWidth += context.measureText(line[k]).width;
                        }
                        // Add character spacing to the estimated width
                        estimatedLineWidth += (line.length - 1) * charSpacing;


                        if (alignment === 'center') {
                            translationX = (CANVAS_WIDTH / 2) - (estimatedLineWidth / 2);
                        } else if (alignment === 'right') {
                            translationX = CANVAS_WIDTH - BASE_PADDING - estimatedLineWidth;
                        } else { // default 'left'
                            translationX = startX;
                        }

                        // Ensure text does not go outside padding if estimatedLineWidth is very large
                        translationX = Math.max(BASE_PADDING, translationX);
                        if (translationX + estimatedLineWidth > CANVAS_WIDTH - BASE_PADDING) {
                            translationX = CANVAS_WIDTH - BASE_PADDING - estimatedLineWidth;
                        }


                        context.translate(translationX, lineActualY);
                        context.rotate(randomLineSkewRad); // Apply rotation after translation

                        let charDrawX = 0; // X position relative to current translation origin

                        // Draw characters in the line
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            const charWidth = context.measureText(char).width;

                            // Apply character jitter (relative to the current rotated line's local coordinates)
                            const charXJitter = (Math.random() - 0.5) * randomnessIntensity;
                            const charYJitter = (Math.random() - 0.5) * randomnessIntensity;

                            context.fillText(char, charDrawX + charXJitter, charYJitter);
                            charDrawX += charWidth + charSpacing; // Advance X for next character, including char spacing
                        }

                        context.restore(); // Restore to previous canvas state

                        currentY += effectiveLineHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5; // Advance Y for next line, add random line spacing

                        // Check if text has gone too far down the page
                        if (currentY + fontSize > (CANVAS_HEIGHT - BASE_PADDING)) {
                            showMessage('æ–‡å­—å†…å®¹è¿‡å¤šï¼Œå¯èƒ½è¶…å‡ºå›¾ç‰‡èŒƒå›´ã€‚');
                            break; // Stop drawing if out of bounds
                        }
                    }
                }
            }


            // Generate Image function
            async function generateImage() {
                const text = inputText.value; // Get raw text, don't trim to preserve spaces
                loadingIndicator.classList.remove('hidden');
                placeholderText.classList.add('hidden'); // Hide placeholder when generating
                outputImage.style.display = 'none'; // Hide old image

                const selectedFont = fontSelect.value;
                const selectedBackground = backgroundSelect.value;
                const selectedTextColor = textColorInput.value;
                const fontSize = parseInt(fontSizeInput.value);
                const charSpacing = parseInt(charSpacingInput.value); // New
                const lineSpacingFactor = parseInt(lineSpacingFactorInput.value); // New

                const textAlignment = textAlignmentSelect.value;
                const topOffsetPercentage = parseInt(topOffsetInput.value);
                const topOffsetPixels = (topOffsetPercentage / 100) * CANVAS_HEIGHT;

                const randomnessIntensity = parseInt(randomnessIntensityInput.value);
                const lineSkewAngle = parseInt(lineSkewAngleInput.value);
                const isVerticalWriting = verticalWritingCheckbox.checked;
                const verticalDirection = verticalDirectionSelect.value;

                outputCanvas.width = CANVAS_WIDTH;
                outputCanvas.height = CANVAS_HEIGHT;

                try {
                    // Draw background
                    if (selectedBackground === 'notebook') {
                        ctx.fillStyle = '#F0F8FF';
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

                        ctx.strokeStyle = '#ADD8E6';
                        ctx.lineWidth = 1;
                        // Use effective line height for notebook lines
                        const notebookLineHeight = fontSize * (lineSpacingFactor / 100);
                        for (let i = BASE_PADDING + topOffsetPixels; i < outputCanvas.height - BASE_PADDING; i += notebookLineHeight) {
                            ctx.beginPath();
                            ctx.moveTo(BASE_PADDING, i);
                            ctx.lineTo(outputCanvas.width - BASE_PADDING, i);
                            ctx.stroke();
                        }
                        ctx.strokeStyle = '#FF6347';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(BASE_PADDING + 20, 0);
                        ctx.lineTo(BASE_PADDING + 20, outputCanvas.height);
                        ctx.stroke();
                    } else if (selectedBackground === 'parchment-texture') {
                        drawParchmentTexture(ctx, outputCanvas.width, outputCanvas.height);
                    } else if (selectedBackground === 'vintage-paper') {
                        drawVintagePaperTexture(ctx, outputCanvas.width, outputCanvas.height);
                    } else if (selectedBackground === 'custom') { // Handle custom background
                        if (uploadedBgImage) {
                            // Draw image to cover the canvas
                            const hRatio = CANVAS_WIDTH / uploadedBgImage.width;
                            const vRatio = CANVAS_HEIGHT / uploadedBgImage.height;
                            const ratio = Math.max(hRatio, vRatio); // Use max to ensure cover
                            const sWidth = uploadedBgImage.width * ratio;
                            const sHeight = uploadedBgImage.height * ratio;
                            const sx = (CANVAS_WIDTH - sWidth) / 2;
                            const sy = (CANVAS_HEIGHT - sHeight) / 2;
                            ctx.drawImage(uploadedBgImage, sx, sy, sWidth, sHeight);
                        } else {
                            // If custom selected but no image uploaded, fallback to white and show message
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                            showMessage('è¯·ä¸Šä¼ è‡ªå®šä¹‰èƒŒæ™¯å›¾ç‰‡ï¼');
                        }
                    } else { // white
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                    }

                    // Only draw text if inputText is not empty after trimming
                    if (text.trim() === '') {
                        placeholderText.classList.remove('hidden'); // Show placeholder if text is empty
                        outputImage.style.display = 'none'; // Hide generated image
                        downloadBtn.classList.add('hidden');
                        copyBtn.classList.add('hidden');
                    } else {
                        drawHandwrittenText(
                            ctx,
                            text,
                            selectedFont,
                            selectedTextColor,
                            fontSize,
                            BASE_PADDING,
                            BASE_PADDING + topOffsetPixels,
                            CANVAS_WIDTH - BASE_PADDING * 2,
                            fontSize * 1.5, // Base line height passed, then modified by lineSpacingFactor inside
                            textAlignment,
                            randomnessIntensity,
                            lineSkewAngle,
                            isVerticalWriting,
                            verticalDirection,
                            charSpacing, // New
                            lineSpacingFactor // New
                        );

                        // Convert Canvas content to image
                        const imageDataUrl = outputCanvas.toDataURL('image/png');
                        outputImage.src = imageDataUrl;
                        outputImage.style.display = 'block';
                        downloadBtn.href = imageDataUrl;
                        downloadBtn.classList.remove('hidden');
                        copyBtn.classList.remove('hidden');
                    }

                } catch (error) {
                    console.error("ç”Ÿæˆå›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯:", error);
                    showMessage("ç”Ÿæˆå›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥æˆ–åˆ·æ–°é¡µé¢ã€‚");
                    // Ensure placeholder is shown if an error occurs during drawing
                    placeholderText.classList.remove('hidden');
                    outputImage.style.display = 'none';
                    downloadBtn.classList.add('hidden');
                    copyBtn.classList.add('hidden');
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }

            // Copy image link functionality
            copyBtn.addEventListener('click', () => {
                const imageDataUrl = outputImage.src;
                if (imageDataUrl) {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = imageDataUrl;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        document.execCommand('copy');
                        showMessage('å›¾ç‰‡é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                    } catch (err) {
                        showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚');
                    }
                    document.body.removeChild(tempInput);
                } else {
                    showMessage('è¯·å…ˆç”Ÿæˆå›¾ç‰‡ï¼');
                }
            });

            // Initial display for sliders
            fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
            charSpacingValueSpan.textContent = `${charSpacingInput.value}px`; // New initial display
            lineSpacingFactorValueSpan.textContent = `${lineSpacingFactorInput.value}%`; // New initial display
            topOffsetValueSpan.textContent = `${topOffsetInput.value}%`;
            randomnessIntensityValueSpan.textContent = randomnessIntensityInput.value;
            lineSkewAngleValueSpan.textContent = `${lineSkewAngleInput.value}Â°`;

            // Canvas background drawing functions (retained from previous versions)
            function drawParchmentTexture(context, width, height) {
                context.fillStyle = '#F5DEB3';
                context.fillRect(0, 0, width, height);
                for (let i = 0; i < 8000; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 0.6 + 0.1;
                    const alpha = Math.random() * 0.2 + 0.1;
                    const color = Math.random() < 0.5 ? 'rgba(0,0,0,' : 'rgba(255,255,255,';
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = color + alpha + ')';
                    context.fill();
                }
            }

            function drawVintagePaperTexture(context, width, height) {
                context.fillStyle = '#FDF6E3';
                context.fillRect(0, 0, width, height);
                for (let i = 0; i < 80; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 40 + 15;
                    const alpha = Math.random() * 0.12 + 0.08;
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = `rgba(139,69,19,${alpha})`;
                    context.fill();
                }
                context.strokeStyle = `rgba(139,69,19,0.05)`;
                context.lineWidth = 0.8;
                for (let i = 0; i < 30; i++) {
                    context.beginPath();
                    context.moveTo(Math.random() * width, Math.random() * height);
                    context.lineTo(Math.random() * width, Math.random() * height);
                    context.stroke();
                }
            }
        });
    </script>
</body>

</html>