<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文字图片生成器</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Google Fonts Import for UI and Handwriting Fonts */
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Smiley+Sans&family=LXGW+WenKai+Lite&family=Ma+Shan+Zheng&family=Liu+Jian+Mao+Cao&family=Long+Cang&family=Noto+Sans+SC:wght@300;400;500;700&family=Noto+Serif+SC:wght@300;400;500;700&family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            /* 使用Inter作为UI界面的默认字体 */
        }

        /* Custom Handwriting Font Styles */
        .font-zcool-kuaile {
            font-family: 'ZCOOL KuaiLe', cursive;
        }

        .font-smiley-sans {
            font-family: 'Smiley Sans', sans-serif;
        }

        .font-lxgw-wenkai {
            font-family: 'LXGW WenKai Lite', cursive;
            /* Using Lite version for broader compatibility */
        }

        .font-ma-shan-zheng {
            font-family: 'Ma Shan Zheng', cursive;
        }

        .font-liu-jian-mao-cao {
            font-family: 'Liu Jian Mao Cao', cursive;
        }

        .font-long-cang {
            font-family: 'Long Cang', cursive;
        }

        /* New Noto Sans SC Styles */
        .font-noto-sans-sc {
            font-family: 'Noto Sans SC', sans-serif;
        }

        /* New Noto Serif SC Styles */
        .font-noto-serif-sc {
            font-family: 'Noto Serif SC', serif;
        }

        /* Hide Canvas, only show Image */
        #outputCanvas {
            display: none;
        }

        /* Custom Slider Styles */
        input[type='range']::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            /* purple-500 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
            /* purple-500 with opacity */
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }

        input[type='range']::-webkit-slider-thumb:hover {
            background: #7c3aed;
            /* purple-600 */
        }

        input[type='range']::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
            transition: background .15s ease-in-out, box-shadow .15s ease-in-out;
        }

        input[type='range']::-moz-range-thumb:hover {
            background: #7c3aed;
        }
    </style>
</head>

<body
    class="bg-gradient-to-br from-purple-100 via-pink-100 to-blue-200 min-h-screen flex items-center justify-center p-6 text-gray-800">

    <div
        class="bg-white p-10 rounded-3xl shadow-2xl max-w-5xl w-full border border-gray-100 transform transition-all duration-300 hover:scale-[1.005]">
        <h1
            class="text-5xl font-extrabold text-center text-purple-700 mb-10 tracking-tight flex items-center justify-center space-x-3">
            <svg class="w-10 h-10 text-pink-500" fill="currentColor" viewBox="0 0 20 20"
                xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd"
                    d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828zM4 12a2 2 0 012-2h.01a.75.75 0 100-1.5H6a3.5 3.5 0 00-3.5 3.5v1.5a.75.75 0 001.5 0V12zM15 15a.75.75 0 00-.75.75v1.5a.75.75 0 01-.75.75H4a2 2 0 01-2-2v-1.5a.75.75 0 00-1.5 0v1.5a3.5 3.5 0 003.5 3.5h9.5a3.5 3.5 0 003.5-3.5v-1.5a.75.75 0 00-1.5 0V15z"
                    clip-rule="evenodd"></path>
            </svg>
            <span>文字图片生成器</span>
        </h1>

        <div class="grid md:grid-cols-2 gap-10">
            <!-- 设置表单 -->
            <div class="space-y-7">
                <div>
                    <label for="inputText" class="block text-lg font-semibold text-gray-700 mb-2">输入文字:</label>
                    <textarea id="inputText"
                        class="w-full p-4 border border-gray-300 rounded-xl focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base h-40 resize-y shadow-sm hover:shadow-md"
                        placeholder="在这里输入你想要生成的文字...（回车和空格会被保留）"></textarea>
                </div>

                <div>
                    <label for="fontSelect" class="block text-lg font-semibold text-gray-700 mb-2">选择字体:</label>
                    <select id="fontSelect"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="LXGW WenKai Lite">霞鹜文楷 (LXGW WenKai Lite)</option>
                        <option value="ZCOOL KuaiLe">站酷快乐体 (ZCOOL KuaiLe)</option>
                        <option value="Smiley Sans">得意黑 (Smiley Sans)</option>
                        <option value="Ma Shan Zheng">马善政 (Ma Shan Zheng)</option>
                        <option value="Liu Jian Mao Cao">刘江毛草 (Liu Jian Mao Cao)</option>
                        <option value="Long Cang">龙藏体 (Long Cang)</option>
                        <option value="Noto Sans SC">思源黑体 (Noto Sans SC)</option>
                        <option value="Noto Serif SC">思源宋体 (Noto Serif SC)</option>
                        <option value="CustomUploadedFont">自定义上传字体 (Custom Uploaded Font)</option>
                    </select>
                </div>

                <!-- Custom Font Upload Section -->
                <div id="customFontUploadContainer" class="hidden space-y-2">
                    <label for="customFontUploadInput" class="block text-lg font-semibold text-gray-700 mb-2">上传字体文件
                        (.ttf, .otf, .woff, .woff2):</label>
                    <input type="file" id="customFontUploadInput" accept=".ttf,.otf,.woff,.woff2"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md cursor-pointer">
                    <span id="fontUploadStatus" class="block text-sm text-gray-600 mt-1">请上传字体文件，如 TTF, OTF, WOFF, WOFF2
                        格式。</span>
                </div>


                <div>
                    <label for="backgroundSelect" class="block text-lg font-semibold text-gray-700 mb-2">选择背景:</label>
                    <select id="backgroundSelect"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="notebook">笔记本</option>
                        <option value="parchment-texture">羊皮纸纹理</option>
                        <option value="vintage-paper">复古纸张</option>
                        <option value="white">纯白</option>
                        <option value="solid">纯色</option>
                        <option value="gradient">渐变色</option>
                        <option value="custom">自定义图片</option>
                    </select>
                </div>

                <!-- Solid Color Picker Container -->
                <div id="solidColorContainer" class="hidden space-y-2">
                    <label for="solidColorPicker" class="block text-lg font-semibold text-gray-700 mb-2">选择纯色:</label>
                    <input type="color" id="solidColorPicker" value="#F0F0F0"
                        class="w-full h-12 border border-gray-300 rounded-xl cursor-pointer focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out shadow-sm hover:shadow-md">
                </div>

                <!-- Gradient Color Picker Container -->
                <div id="gradientColorContainer" class="hidden space-y-2">
                    <label class="block text-lg font-semibold text-gray-700 mb-2">渐变色设置:</label>
                    <div class="flex items-center space-x-4">
                        <div class="flex-1">
                            <label for="gradientStartColor"
                                class="block text-sm font-medium text-gray-700 mb-1">起始颜色:</label>
                            <input type="color" id="gradientStartColor" value="#ADD8E6"
                                class="w-full h-10 border border-gray-300 rounded-lg cursor-pointer focus:ring-2 focus:ring-purple-400">
                        </div>
                        <div class="flex-1">
                            <label for="gradientEndColor"
                                class="block text-sm font-medium text-gray-700 mb-1">结束颜色:</label>
                            <input type="color" id="gradientEndColor" value="#E6B0AD"
                                class="w-full h-10 border border-gray-300 rounded-lg cursor-pointer focus:ring-2 focus:ring-purple-400">
                        </div>
                    </div>
                    <!-- New: Gradient Angle Control -->
                    <div class="mt-4">
                        <label for="gradientAngleInput" class="block text-sm font-medium text-gray-700 mb-1">渐变角度
                            (度):</label>
                        <input type="range" id="gradientAngleInput" min="0" max="360" value="180"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="gradientAngleValue" class="block text-sm text-gray-600 mt-2 text-right">180°</span>
                    </div>
                </div>

                <!-- 自定义背景上传 -->
                <div id="customBgUploadContainer" class="hidden">
                    <label for="customBgUpload"
                        class="block text-lg font-semibold text-gray-700 mb-2">上传自定义背景图片:</label>
                    <input type="file" id="customBgUpload" accept="image/*"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md cursor-pointer">
                    <span class="block text-sm text-gray-600 mt-1">支持 JPG, PNG 等格式。图片将自动缩放以覆盖整个背景。</span>
                </div>


                <div>
                    <label for="textColor" class="block text-lg font-semibold text-gray-700 mb-2">文字颜色:</label>
                    <input type="color" id="textColor" value="#333333"
                        class="w-full h-12 border border-gray-300 rounded-xl cursor-pointer focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out shadow-sm hover:shadow-md">
                </div>

                <div>
                    <label for="fontSize" class="block text-lg font-semibold text-gray-700 mb-2">字体大小:</label>
                    <input type="range" id="fontSize" min="20" max="80" value="40"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="fontSizeValue" class="block text-sm text-gray-600 mt-2 text-right">40px</span>
                </div>

                <!-- 字间距和行间距 -->
                <div>
                    <label for="charSpacing" class="block text-lg font-semibold text-gray-700 mb-2">字间距:</label>
                    <input type="range" id="charSpacing" min="-10" max="20" value="0"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="charSpacingValue" class="block text-sm text-gray-600 mt-2 text-right">0px</span>
                    <span class="block text-sm text-gray-600 mt-1">调整字符之间的额外空间。</span>
                </div>

                <div>
                    <label for="lineSpacingFactor" class="block text-lg font-semibold text-gray-700 mb-2">行间距:</label>
                    <input type="range" id="lineSpacingFactor" min="80" max="200" value="100"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="lineSpacingFactorValue" class="block text-sm text-gray-600 mt-2 text-right">100%</span>
                    <span class="block text-sm text-gray-600 mt-1">调整行与行之间的额外空间 (100% 为默认)。</span>
                </div>


                <!-- 文字位置设置 -->
                <div>
                    <label for="textAlignment" class="block text-lg font-semibold text-gray-700 mb-2">文字位置 (水平):</label>
                    <select id="textAlignment"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="left">居左</option>
                        <option value="center">居中</option>
                        <option value="right">居右</option>
                    </select>
                </div>

                <div>
                    <label for="topOffset" class="block text-lg font-semibold text-gray-700 mb-2">距离顶部 (%):</label>
                    <input type="range" id="topOffset" min="0" max="50" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="topOffsetValue" class="block text-sm text-gray-600 mt-2 text-right">5%</span>
                    <span class="block text-sm text-gray-600 mt-1">设置文字内容块距离图片顶部的百分比。</span>
                </div>

                <!-- 随机抖动强度 -->
                <div>
                    <label for="randomnessIntensity"
                        class="block text-lg font-semibold text-gray-700 mb-2">随机抖动强度:</label>
                    <input type="range" id="randomnessIntensity" min="0" max="25" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="randomnessIntensityValue" class="block text-sm text-gray-600 mt-2 text-right">5</span>
                    <span class="block text-sm text-gray-600 mt-1">增加文字的随机偏移，模拟手写不规则感（0为无抖动）。</span>
                </div>

                <!-- 随机倾斜角度 -->
                <div>
                    <label for="lineSkewAngle" class="block text-lg font-semibold text-gray-700 mb-2">随机倾斜角度
                        (度):</label>
                    <input type="range" id="lineSkewAngle" min="0" max="15" value="0"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="lineSkewAngleValue" class="block text-sm text-gray-600 mt-2 text-right">0°</span>
                    <span class="block text-sm text-gray-600 mt-1">设置每行/字符的随机倾斜范围（0为无倾斜）。</span>
                </div>

                <!-- 垂直书写模式 -->
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="verticalWriting"
                        class="h-5 w-5 text-purple-600 rounded focus:ring-purple-500 cursor-pointer">
                    <label for="verticalWriting" class="text-lg font-semibold text-gray-700">垂直书写模式</label>
                </div>

                <!-- 垂直书写方向选项 -->
                <div class="space-y-3" id="verticalDirectionOptions" style="display: none;"> <!-- 初始隐藏 -->
                    <label for="verticalDirection"
                        class="block text-lg font-semibold text-gray-700 mb-2">垂直书写方向:</label>
                    <select id="verticalDirection"
                        class="w-full p-3 border border-gray-300 rounded-xl bg-white focus:ring-4 focus:ring-purple-300 focus:border-transparent transition duration-300 ease-in-out text-base shadow-sm hover:shadow-md">
                        <option value="ltr">从左到右</option>
                        <option value="rtl">从右到左</option>
                    </select>
                </div>

                <!-- 生成按钮 - 字体加载后启用 -->
                <button id="generateBtn"
                    class="w-full bg-gradient-to-r from-purple-600 to-pink-500 text-white py-4 rounded-xl text-2xl font-bold hover:from-purple-700 hover:to-pink-600 focus:outline-none focus:ring-6 focus:ring-purple-400 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95"
                    disabled>生成图片 (加载中...)</button>

                <div id="loadingIndicator"
                    class="hidden text-center text-purple-600 font-semibold text-lg mt-4 animate-pulse">
                    正在生成图片，请稍候...
                </div>
            </div>

            <!-- 图片预览区 -->
            <div
                class="bg-gray-100 p-8 rounded-2xl shadow-inner flex items-center justify-center min-h-[400px] border border-gray-200 relative overflow-hidden">
                <img id="outputImage" class="max-w-full h-auto rounded-lg shadow-xl" alt="生成的图片"
                    style="max-height: 500px; display: none;">
                <canvas id="outputCanvas" class="border border-gray-300 rounded-lg shadow-md"></canvas>
                <p id="placeholderText" class="text-gray-500 text-center text-xl font-medium">输入文字并调整设置以生成图片</p>
            </div>
        </div>

        <!-- 底部操作按钮 -->
        <div class="mt-10 flex justify-center space-x-6">
            <a id="downloadBtn" download="generated_text_image.png"
                class="hidden bg-gradient-to-r from-green-500 to-teal-500 text-white py-3 px-8 rounded-xl text-lg font-semibold hover:from-green-600 hover:to-teal-600 focus:outline-none focus:ring-6 focus:ring-green-300 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95">下载图片</a>
            <button id="copyBtn"
                class="hidden bg-gradient-to-r from-blue-500 to-cyan-500 text-white py-3 px-8 rounded-xl text-lg font-semibold hover:from-blue-600 hover:to-cyan-600 focus:outline-none focus:ring-6 focus:ring-blue-300 transform transition duration-300 ease-in-out hover:scale-105 shadow-lg active:scale-95">复制图片链接</button>
            <div id="messageBox"
                class="fixed bottom-8 right-8 bg-black bg-opacity-80 text-white py-3 px-6 rounded-lg shadow-xl text-sm hidden z-50">
            </div>
        </div>

        <!-- Mobile Save Tip -->
        <div id="mobileSaveTip"
            class="hidden text-center mt-8 p-4 bg-yellow-50 border border-yellow-200 text-yellow-800 rounded-lg shadow-sm">
            <p class="font-semibold text-lg mb-2">📢 手机端保存提示：</p>
            <p class="text-base">
                由于系统限制，网页无法直接保存图片到相册。
                请在上方生成的图片上 **长按（或重按）**，然后选择菜单中的 **“保存图片”** 或 **“添加到照片”** 即可保存到您的设备相册。
            </p>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get all necessary DOM elements
            const inputText = document.getElementById('inputText');
            const fontSelect = document.getElementById('fontSelect');
            const backgroundSelect = document.getElementById('backgroundSelect');
            const customBgUploadContainer = document.getElementById('customBgUploadContainer');
            const customBgUpload = document.getElementById('customBgUpload');
            // Background color pickers and gradient options
            const solidColorContainer = document.getElementById('solidColorContainer');
            const solidColorPicker = document.getElementById('solidColorPicker');
            const gradientColorContainer = document.getElementById('gradientColorContainer');
            const gradientStartColor = document.getElementById('gradientStartColor');
            const gradientEndColor = document.getElementById('gradientEndColor');
            const gradientAngleInput = document.getElementById('gradientAngleInput'); // New gradient angle input
            const gradientAngleValueSpan = document.getElementById('gradientAngleValue'); // New gradient angle value span


            const textColorInput = document.getElementById('textColor');
            const fontSizeInput = document.getElementById('fontSize');
            const fontSizeValueSpan = document.getElementById('fontSizeValue');
            const charSpacingInput = document.getElementById('charSpacing');
            const charSpacingValueSpan = document.getElementById('charSpacingValue');
            const lineSpacingFactorInput = document.getElementById('lineSpacingFactor');
            const lineSpacingFactorValueSpan = document.getElementById('lineSpacingFactorValue');
            const textAlignmentSelect = document.getElementById('textAlignment');
            const topOffsetInput = document.getElementById('topOffset');
            const topOffsetValueSpan = document.getElementById('topOffsetValue');
            const randomnessIntensityInput = document.getElementById('randomnessIntensity');
            const randomnessIntensityValueSpan = document.getElementById('randomnessIntensityValue');
            const lineSkewAngleInput = document.getElementById('lineSkewAngle');
            const lineSkewAngleValueSpan = document.getElementById('lineSkewAngleValue');
            const verticalWritingCheckbox = document.getElementById('verticalWriting');
            const verticalDirectionOptions = document.getElementById('verticalDirectionOptions');
            const verticalDirectionSelect = document.getElementById('verticalDirection');
            const generateBtn = document.getElementById('generateBtn');
            const outputImage = document.getElementById('outputImage');
            const outputCanvas = document.getElementById('outputCanvas');
            const downloadBtn = document.getElementById('downloadBtn');
            const copyBtn = document.getElementById('copyBtn');
            const placeholderText = document.getElementById('placeholderText');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const messageBox = document.getElementById('messageBox');
            const mobileSaveTip = document.getElementById('mobileSaveTip');
            const ctx = outputCanvas.getContext('2d');

            // Custom Font DOM elements
            const customFontUploadContainer = document.getElementById('customFontUploadContainer');
            const customFontUploadInput = document.getElementById('customFontUploadInput');
            const fontUploadStatus = document.getElementById('fontUploadStatus');


            // Fixed Canvas dimensions for 9:16 aspect ratio
            const CANVAS_WIDTH = 720;
            const CANVAS_HEIGHT = 1280;
            const BASE_PADDING = 60; // Base padding from canvas edges

            let debounceTimer; // For debouncing text input
            let uploadedBgImage = null; // Store the uploaded background image object
            let customFontLoaded = false; // Track if a custom font has been successfully loaded

            // Function to debounce calls
            const debounce = (func, delay) => {
                return function (...args) {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => func.apply(this, args), delay);
                };
            };

            // Initially disable the generate button, enable after fonts load
            generateBtn.disabled = true;
            generateBtn.textContent = '生成图片 (加载中...)';

            // Wait for all Google Fonts to be loaded
            document.fonts.ready.then(() => {
                generateBtn.disabled = false;
                generateBtn.textContent = '生成图片';
                // Trigger initial image generation once fonts are loaded
                generateImage(); // Initial render

                // Attach event listeners for real-time updates
                inputText.addEventListener('input', debounce(generateImage, 500)); // Debounce text input
                fontSelect.addEventListener('change', () => {
                    // Toggle custom font upload container visibility
                    if (fontSelect.value === 'CustomUploadedFont') {
                        customFontUploadContainer.classList.remove('hidden');
                    } else {
                        customFontUploadContainer.classList.add('hidden');
                        // Reset custom font status if switching away
                        fontUploadStatus.textContent = '请上传字体文件，如 TTF, OTF, WOFF, WOFF2 格式。';
                        fontUploadStatus.classList.remove('text-green-600', 'text-red-600', 'text-purple-600');
                        fontUploadStatus.classList.add('text-gray-600');
                    }
                    generateImage();
                });
                customFontUploadInput.addEventListener('change', handleFontUpload); // Handle font upload

                // Background selection change handler
                backgroundSelect.addEventListener('change', () => {
                    const selectedBg = backgroundSelect.value;
                    // Hide all background-specific containers first
                    customBgUploadContainer.classList.add('hidden');
                    solidColorContainer.classList.add('hidden');
                    gradientColorContainer.classList.add('hidden');
                    uploadedBgImage = null; // Clear custom image if switching away

                    // Show the relevant container based on selection
                    if (selectedBg === 'custom') {
                        customBgUploadContainer.classList.remove('hidden');
                    } else if (selectedBg === 'solid') {
                        solidColorContainer.classList.remove('hidden');
                    } else if (selectedBg === 'gradient') {
                        gradientColorContainer.classList.remove('hidden');
                    }
                    generateImage();
                });
                customBgUpload.addEventListener('change', handleImageUpload); // Handle background image upload

                // Listeners for solid and gradient color pickers/selectors
                solidColorPicker.addEventListener('input', generateImage);
                gradientStartColor.addEventListener('input', generateImage);
                gradientEndColor.addEventListener('input', generateImage);
                gradientAngleInput.addEventListener('input', generateImage); // New listener for gradient angle


                textColorInput.addEventListener('input', generateImage);
                fontSizeInput.addEventListener('input', generateImage);
                charSpacingInput.addEventListener('input', generateImage);
                lineSpacingFactorInput.addEventListener('input', generateImage);
                textAlignmentSelect.addEventListener('change', generateImage);
                topOffsetInput.addEventListener('input', generateImage);
                randomnessIntensityInput.addEventListener('input', generateImage);
                lineSkewAngleInput.addEventListener('input', generateImage);
                verticalWritingCheckbox.addEventListener('change', () => {
                    // Toggle vertical writing options visibility and enable/disable horizontal alignment
                    if (verticalWritingCheckbox.checked) {
                        verticalDirectionOptions.style.display = 'block';
                        textAlignmentSelect.disabled = true;
                        textAlignmentSelect.value = 'left'; // Reset to left if user unchecks later
                    } else {
                        verticalDirectionOptions.style.display = 'none';
                        textAlignmentSelect.disabled = false;
                    }
                    generateImage(); // Trigger update immediately on checkbox change
                });
                verticalDirectionSelect.addEventListener('change', generateImage);

                // Show mobile save tip if on a mobile device
                if (/Mobi|Android/i.test(navigator.userAgent)) {
                    mobileSaveTip.classList.remove('hidden');
                }

            }).catch(error => {
                console.error("字体加载失败:", error);
                showMessage("字体加载失败，请刷新页面重试。");
                generateBtn.textContent = '字体加载失败';
            });

            // Handle custom font upload
            async function handleFontUpload(event) {
                const file = event.target.files[0];
                if (!file) {
                    fontUploadStatus.textContent = '未选择字体文件。';
                    fontUploadStatus.classList.remove('hidden', 'text-green-600', 'text-red-600', 'text-purple-600');
                    fontUploadStatus.classList.add('text-gray-600');
                    customFontLoaded = false;
                    generateImage(); // Trigger redraw with current (possibly default) font
                    return;
                }

                fontUploadStatus.textContent = '正在加载字体...';
                fontUploadStatus.classList.remove('hidden', 'text-green-600', 'text-red-600', 'text-gray-600');
                fontUploadStatus.classList.add('text-purple-600');
                customFontLoaded = false; // Reset status

                try {
                    const fontName = 'CustomUploadedFont'; // Fixed name for simplicity
                    const fontUrl = URL.createObjectURL(file); // Create URL for the font file

                    // Remove any previously loaded custom font with the same name
                    for (const f of document.fonts.values()) {
                        if (f.family === fontName) {
                            document.fonts.delete(f);
                            break;
                        }
                    }

                    const customFontFace = new FontFace(fontName, `url(${fontUrl})`);
                    await customFontFace.load(); // Load the font
                    document.fonts.add(customFontFace); // Add to document fonts
                    URL.revokeObjectURL(fontUrl); // Clean up the object URL

                    fontUploadStatus.textContent = `字体 "${file.name}" 加载成功！`;
                    fontUploadStatus.classList.remove('text-purple-600', 'text-red-600', 'text-gray-600');
                    fontUploadStatus.classList.add('text-green-600');
                    customFontLoaded = true; // Mark as loaded

                    fontSelect.value = fontName; // Select the custom font in the dropdown
                    generateImage(); // Regenerate image with the new font
                } catch (error) {
                    console.error("加载自定义字体失败:", error);
                    fontUploadStatus.textContent = `加载自定义字体失败: ${error.message || '文件损坏或格式不正确'}`;
                    fontUploadStatus.classList.remove('text-purple-600', 'text-green-600', 'text-gray-600');
                    fontUploadStatus.classList.add('text-red-600');
                    customFontLoaded = false; // Mark as failed
                    // If custom font failed, ensure we revert to a default working font or alert user to change selection
                    if (fontSelect.value === 'CustomUploadedFont') {
                        fontSelect.value = 'LXGW WenKai Lite'; // Fallback to a default font
                        generateImage();
                    }
                }
            }


            // Handle custom background image upload
            function handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) {
                    uploadedBgImage = null; // Clear if no file selected
                    generateImage(); // Regenerate with current background
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedBgImage = img; // Store the loaded image
                        generateImage(); // Regenerate with new custom background
                    };
                    img.onerror = () => {
                        showMessage('图片加载失败，请尝试其他图片。');
                        uploadedBgImage = null;
                        generateImage(); // Fallback
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    showMessage('文件读取失败，请重试。');
                    uploadedBgImage = null;
                    generateImage(); // Fallback
                };
                reader.readAsDataURL(file);
            }


            // Update slider value displays and trigger image generation
            fontSizeInput.addEventListener('input', () => {
                fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
                generateImage();
            });
            charSpacingInput.addEventListener('input', () => {
                charSpacingValueSpan.textContent = `${charSpacingInput.value}px`;
                generateImage();
            });
            lineSpacingFactorInput.addEventListener('input', () => {
                lineSpacingFactorValueSpan.textContent = `${lineSpacingFactorInput.value}%`;
                generateImage();
            });
            topOffsetInput.addEventListener('input', () => {
                topOffsetValueSpan.textContent = `${topOffsetInput.value}%`;
                generateImage();
            });
            randomnessIntensityInput.addEventListener('input', () => {
                randomnessIntensityValueSpan.textContent = randomnessIntensityInput.value;
                generateImage();
            });
            lineSkewAngleInput.addEventListener('input', () => {
                lineSkewAngleValueSpan.textContent = `${lineSkewAngleInput.value}°`;
                generateImage();
            });
            gradientAngleInput.addEventListener('input', () => { // New listener for gradient angle
                gradientAngleValueSpan.textContent = `${gradientAngleInput.value}°`;
                generateImage();
            });


            // Show message box temporarily
            function showMessage(message) {
                messageBox.textContent = message;
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 3000); // Hide after 3 seconds
            }

            // Function to draw text on canvas
            function drawHandwrittenText(context, text, font, textColor, fontSize, startX, startY, maxWidth, alignment, randomnessIntensity, lineSkewAngle, isVertical, verticalDirection, charSpacing, lineSpacingFactor) {
                console.log("drawHandwrittenText: 开始绘制文字...");
                console.log(`- 字体: ${font}, 大小: ${fontSize}px, 颜色: ${textColor}`);
                console.log(`- 起始坐标: (${startX}, ${startY}), 最大宽度: ${maxWidth}`);
                console.log(`- 对齐: ${alignment}, 抖动: ${randomnessIntensity}, 倾斜: ${lineSkewAngle}°`);
                console.log(`- 垂直模式: ${isVertical}, 方向: ${verticalDirection}, 字间距: ${charSpacing}, 行间距因子: ${lineSpacingFactor}%`);

                context.fillStyle = textColor;
                context.font = `${fontSize}px "${font}"`; // Use the selected font family
                context.textBaseline = 'top';

                const textLines = text.split('\n'); // Preserve user's newlines

                if (isVertical) {
                    console.log("drawHandwrittenText: 垂直模式");
                    let currentColumnX;
                    const effectiveCharHeight = fontSize * (lineSpacingFactor / 100);
                    const baseColumnAdvance = fontSize + charSpacing;

                    if (verticalDirection === 'rtl') {
                        currentColumnX = CANVAS_WIDTH - BASE_PADDING - fontSize;
                    } else {
                        currentColumnX = startX;
                    }

                    let currentColumnY = startY;

                    for (let lineIndex = 0; lineIndex < textLines.length; lineIndex++) {
                        const lineContent = textLines[lineIndex];

                        if (lineIndex > 0 || (currentColumnY > startY && lineContent.length > 0)) {
                            if (verticalDirection === 'rtl') {
                                currentColumnX -= (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                            } else {
                                currentColumnX += (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                            }
                            currentColumnY = startY;

                            if (verticalDirection === 'rtl' && currentColumnX < BASE_PADDING - (fontSize / 2)) {
                                showMessage(`垂直模式文字超出图片左侧边界，请减少内容或调整设置。当前X: ${currentColumnX.toFixed(2)}`);
                                console.warn("垂直模式文字超出图片左侧边界，停止绘制。");
                                return;
                            }
                            if (verticalDirection === 'ltr' && currentColumnX + fontSize > CANVAS_WIDTH - BASE_PADDING + (fontSize / 2)) {
                                showMessage(`垂直模式文字超出图片右侧边界，请减少内容或调整设置。当前X: ${currentColumnX.toFixed(2)}`);
                                console.warn("垂直模式文字超出图片右侧边界，停止绘制。");
                                return;
                            }
                        }
                        console.log(`- 绘制列 (行 ${lineIndex + 1}): X=${currentColumnX.toFixed(2)}, Y=${currentColumnY.toFixed(2)}`);

                        for (let i = 0; i < lineContent.length; i++) {
                            const char = lineContent[i];

                            if (char === ' ') {
                                currentColumnY += effectiveCharHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5;
                                console.log(`  跳过空格。下一字符Y: ${currentColumnY.toFixed(2)}`);
                                continue;
                            }

                            const charXJitter = (Math.random() - 0.5) * randomnessIntensity;
                            const charYJitter = (Math.random() - 0.5) * randomnessIntensity;

                            context.save();
                            context.translate(currentColumnX + charXJitter, currentColumnY + charYJitter);

                            const randomCharSkewRad = ((Math.random() - 0.5) * lineSkewAngle) * Math.PI / 180;
                            context.rotate(randomCharSkewRad);

                            context.textAlign = 'center';
                            context.fillText(char, 0, 0);
                            console.log(`  绘制字符: "${char}" @(${currentColumnX.toFixed(2)}, ${currentColumnY.toFixed(2)}), 抖动: (${charXJitter.toFixed(2)}, ${charYJitter.toFixed(2)}), 倾斜: ${randomCharSkewRad.toFixed(2)}rad`);

                            context.restore();

                            currentColumnY += effectiveCharHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5;

                            if (currentColumnY + fontSize > CANVAS_HEIGHT - BASE_PADDING) {
                                console.log(`  列已满。当前Y: ${currentColumnY.toFixed(2)}, 画布底部限制: ${CANVAS_HEIGHT - BASE_PADDING}. 切换到下一列。`);
                                currentColumnY = startY;
                                if (verticalDirection === 'rtl') {
                                    currentColumnX -= (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                                } else {
                                    currentColumnX += (baseColumnAdvance + (Math.random() - 0.5) * randomnessIntensity * 1.5);
                                }

                                if (verticalDirection === 'rtl' && currentColumnX < BASE_PADDING - (fontSize / 2)) {
                                    showMessage('垂直模式文字超出图片左侧边界，请减少内容或调整设置。');
                                    console.warn("垂直模式文字超出图片左侧边界，停止绘制。");
                                    return;
                                }
                                if (verticalDirection === 'ltr' && currentColumnX + fontSize > CANVAS_WIDTH - BASE_PADDING + (fontSize / 2)) {
                                    showMessage('垂直模式文字超出图片右侧边界，请减少内容或调整设置。');
                                    console.warn("垂直模式文字超出图片右侧边界，停止绘制。");
                                    return;
                                }
                            }
                        }
                    }

                } else {
                    console.log("drawHandwrittenText: 水平模式");
                    let currentY = startY;
                    const effectiveLineHeight = fontSize * (lineSpacingFactor / 100);

                    for (let i = 0; i < textLines.length; i++) {
                        const line = textLines[i];
                        if (line === '') {
                            currentY += effectiveLineHeight;
                            console.log(`- 跳过空行。下一行Y: ${currentY.toFixed(2)}`);
                            continue;
                        }

                        const lineYJitter = (Math.random() - 0.5) * randomnessIntensity;
                        let lineActualY = currentY + lineYJitter;

                        const randomLineSkewRad = ((Math.random() - 0.5) * lineSkewAngle) * Math.PI / 180;

                        context.save();

                        let translationX;
                        let estimatedLineWidth = 0;
                        for (let k = 0; k < line.length; k++) {
                            estimatedLineWidth += context.measureText(line[k]).width;
                        }
                        estimatedLineWidth += (line.length - 1) * charSpacing;


                        if (alignment === 'center') {
                            translationX = (CANVAS_WIDTH / 2) - (estimatedLineWidth / 2);
                        } else if (alignment === 'right') {
                            translationX = CANVAS_WIDTH - BASE_PADDING - estimatedLineWidth;
                        } else {
                            translationX = startX;
                        }

                        translationX = Math.max(BASE_PADDING, translationX);
                        if (translationX + estimatedLineWidth > CANVAS_WIDTH - BASE_PADDING) {
                            translationX = CANVAS_WIDTH - BASE_PADDING - estimatedLineWidth;
                        }

                        context.translate(translationX, lineActualY);
                        context.rotate(randomLineSkewRad);

                        let charDrawX = 0;

                        console.log(`- 绘制行: "${line}" @(${translationX.toFixed(2)}, ${lineActualY.toFixed(2)}), 倾斜: ${randomLineSkewRad.toFixed(2)}rad`);
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            const charWidth = context.measureText(char).width;

                            const charXJitter = (Math.random() - 0.5) * randomnessIntensity;
                            const charYJitter = (Math.random() - 0.5) * randomnessIntensity;

                            context.fillText(char, charDrawX + charXJitter, charYJitter);
                            charDrawX += charWidth + charSpacing;
                            console.log(`  绘制字符: "${char}" @(${charDrawX.toFixed(2)}, ${charYJitter.toFixed(2)}), 抖动: (${charXJitter.toFixed(2)}, ${charYJitter.toFixed(2)})`);
                        }

                        context.restore();

                        currentY += effectiveLineHeight + (Math.random() - 0.5) * randomnessIntensity * 0.5;

                        if (currentY + fontSize > (CANVAS_HEIGHT - BASE_PADDING)) {
                            showMessage(`文字内容过多，可能超出图片范围。当前Y: ${currentY.toFixed(2)}, 画布底部限制: ${CANVAS_HEIGHT - BASE_PADDING}`);
                            console.warn("水平模式文字超出图片范围，停止绘制。");
                            break;
                        }
                    }
                }
            }


            // Generate Image function
            async function generateImage() {
                const text = inputText.value; // Get raw text, don't trim to preserve spaces
                loadingIndicator.classList.remove('hidden');
                placeholderText.classList.add('hidden'); // Hide placeholder when generating
                outputImage.style.display = 'none'; // Hide old image

                console.log("generateImage: 开始生成图片...");
                console.log(`输入文本: "${text}"`);

                const selectedFont = fontSelect.value;
                const selectedBackground = backgroundSelect.value;
                const selectedTextColor = textColorInput.value;
                const fontSize = parseInt(fontSizeInput.value);
                const charSpacing = parseInt(charSpacingInput.value);
                const lineSpacingFactor = parseInt(lineSpacingFactorInput.value);

                const textAlignment = textAlignmentSelect.value;
                const topOffsetPercentage = parseInt(topOffsetInput.value);
                const topOffsetPixels = (topOffsetPercentage / 100) * CANVAS_HEIGHT;

                const randomnessIntensity = parseInt(randomnessIntensityInput.value);
                const lineSkewAngle = parseInt(lineSkewAngleInput.value);
                const isVerticalWriting = verticalWritingCheckbox.checked;
                const verticalDirection = verticalDirectionSelect.value;

                outputCanvas.width = CANVAS_WIDTH;
                outputCanvas.height = CANVAS_HEIGHT;
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height); // Explicitly clear canvas

                try {
                    // Draw background
                    if (selectedBackground === 'notebook') {
                        ctx.fillStyle = '#F0F8FF';
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

                        ctx.strokeStyle = '#ADD8E6';
                        ctx.lineWidth = 1;
                        const notebookLineHeight = fontSize * (lineSpacingFactor / 100);
                        for (let i = BASE_PADDING + topOffsetPixels; i < outputCanvas.height - BASE_PADDING; i += notebookLineHeight) {
                            ctx.beginPath();
                            ctx.moveTo(BASE_PADDING, i);
                            ctx.lineTo(outputCanvas.width - BASE_PADDING, i);
                            ctx.stroke();
                        }
                        ctx.strokeStyle = '#FF6347';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(BASE_PADDING + 20, 0);
                        ctx.lineTo(BASE_PADDING + 20, outputCanvas.height);
                        ctx.stroke();
                        console.log("背景: 笔记本");
                    } else if (selectedBackground === 'parchment-texture') {
                        drawParchmentTexture(ctx, outputCanvas.width, outputCanvas.height);
                        console.log("背景: 羊皮纸纹理");
                    } else if (selectedBackground === 'vintage-paper') {
                        drawVintagePaperTexture(ctx, outputCanvas.width, outputCanvas.height);
                        console.log("背景: 复古纸张");
                    } else if (selectedBackground === 'custom') {
                        if (uploadedBgImage) {
                            const hRatio = CANVAS_WIDTH / uploadedBgImage.width;
                            const vRatio = CANVAS_HEIGHT / uploadedBgImage.height;
                            const ratio = Math.max(hRatio, vRatio);
                            const sWidth = uploadedBgImage.width * ratio;
                            const sHeight = uploadedBgImage.height * ratio;
                            const sx = (CANVAS_WIDTH - sWidth) / 2;
                            const sy = (CANVAS_HEIGHT - sHeight) / 2;
                            ctx.drawImage(uploadedBgImage, sx, sy, sWidth, sHeight);
                            console.log("背景: 自定义图片");
                        } else {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                            showMessage('请上传自定义背景图片！');
                            console.warn("背景: 自定义图片但未上传，使用白色背景。");
                        }
                    } else if (selectedBackground === 'solid') {
                        ctx.fillStyle = solidColorPicker.value;
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                        console.log(`背景: 纯色 ${solidColorPicker.value}`);
                    } else if (selectedBackground === 'gradient') {
                        const startColor = gradientStartColor.value;
                        const endColor = gradientEndColor.value;
                        const angleInDegrees = parseInt(gradientAngleInput.value);

                        // Convert angle to radians and adjust for canvas coordinate system (0deg is usually right, we want top).
                        // HTML Canvas's createLinearGradient works with absolute coordinates for (x0, y0, x1, y1).
                        // To get a gradient line that fills the canvas at a specific angle:
                        // The line goes from (cx - cos(angle)*L, cy - sin(angle)*L) to (cx + cos(angle)*L, cy + sin(angle)*L)
                        // where L is half the diagonal length of the canvas, ensuring it covers the whole area.
                        const angleInRadians = (angleInDegrees - 90) * Math.PI / 180; // Adjust for 0deg being top-to-bottom

                        const center_x = CANVAS_WIDTH / 2;
                        const center_y = CANVAS_HEIGHT / 2;
                        const length = Math.sqrt(CANVAS_WIDTH * CANVAS_WIDTH + CANVAS_HEIGHT * CANVAS_HEIGHT) / 2; // Half diagonal

                        const x0 = center_x - Math.cos(angleInRadians) * length;
                        const y0 = center_y - Math.sin(angleInRadians) * length;
                        const x1 = center_x + Math.cos(angleInRadians) * length;
                        const y1 = center_y + Math.sin(angleInRadians) * length;

                        const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                        gradient.addColorStop(0, startColor);
                        gradient.addColorStop(1, endColor);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                        console.log(`背景: 渐变色 ${startColor} -> ${endColor}, 角度: ${angleInDegrees}°`);
                    }
                    else { // Default to white if none selected or unknown value
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                        console.log("背景: 默认纯白（未知或未选）");
                    }

                    // Draw text only if there's *any* content, including spaces, for consistency
                    if (text.length === 0) { // Check raw length for truly empty
                        placeholderText.classList.remove('hidden');
                        outputImage.style.display = 'none';
                        downloadBtn.classList.add('hidden');
                        copyBtn.classList.add('hidden');
                        console.log("文本为空，显示占位符。");
                    } else {
                        drawHandwrittenText(
                            ctx,
                            text,
                            selectedFont,
                            selectedTextColor,
                            fontSize,
                            BASE_PADDING,
                            BASE_PADDING + topOffsetPixels,
                            CANVAS_WIDTH - BASE_PADDING * 2,
                            textAlignment,
                            randomnessIntensity,
                            lineSkewAngle,
                            isVerticalWriting,
                            verticalDirection,
                            charSpacing,
                            lineSpacingFactor
                        );

                        // Convert Canvas content to image
                        const imageDataUrl = outputCanvas.toDataURL('image/png');
                        outputImage.src = imageDataUrl;
                        outputImage.style.display = 'block';
                        downloadBtn.href = imageDataUrl;
                        downloadBtn.classList.remove('hidden');
                        copyBtn.classList.remove('hidden');
                        console.log("图片生成成功。");
                    }

                } catch (error) {
                    console.error("生成图片时发生错误:", error);
                    showMessage("生成图片时发生错误，请检查输入或刷新页面。");
                    placeholderText.classList.remove('hidden');
                    outputImage.style.display = 'none';
                    downloadBtn.classList.add('hidden');
                    copyBtn.classList.add('hidden');
                } finally {
                    loadingIndicator.classList.add('hidden');
                    console.log("生成图片过程结束。");
                }
            }

            // Copy image link functionality
            copyBtn.addEventListener('click', () => {
                const imageDataUrl = outputImage.src;
                if (imageDataUrl) {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = imageDataUrl;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        document.execCommand('copy');
                        showMessage('图片链接已复制到剪贴板！');
                    } catch (err) {
                        showMessage('复制失败，请手动复制。');
                    }
                    document.body.removeChild(tempInput);
                } else {
                    showMessage('请先生成图片！');
                }
            });

            // Initial display for sliders
            fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
            charSpacingValueSpan.textContent = `${charSpacingInput.value}px`;
            lineSpacingFactorValueSpan.textContent = `${lineSpacingFactorInput.value}%`;
            topOffsetValueSpan.textContent = `${topOffsetInput.value}%`;
            randomnessIntensityValueSpan.textContent = randomnessIntensityInput.value;
            lineSkewAngleValueSpan.textContent = `${lineSkewAngleInput.value}°`;
            gradientAngleValueSpan.textContent = `${gradientAngleInput.value}°`; // Initial display for gradient angle

            // Canvas background drawing functions (retained from previous versions)
            function drawParchmentTexture(context, width, height) {
                context.fillStyle = '#F5DEB3';
                context.fillRect(0, 0, width, height);
                for (let i = 0; i < 8000; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 0.6 + 0.1;
                    const alpha = Math.random() * 0.2 + 0.1;
                    const color = Math.random() < 0.5 ? 'rgba(0,0,0,' : 'rgba(255,255,255,';
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = color + alpha + ')';
                    context.fill();
                }
            }

            function drawVintagePaperTexture(context, width, height) {
                context.fillStyle = '#FDF6E3';
                context.fillRect(0, 0, width, height);
                for (let i = 0; i < 80; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 40 + 15;
                    const alpha = Math.random() * 0.12 + 0.08;
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = `rgba(139,69,19,${alpha})`;
                    context.fill();
                }
                context.strokeStyle = `rgba(139,69,19,0.05)`;
                context.lineWidth = 0.8;
                for (let i = 0; i < 30; i++) {
                    context.beginPath();
                    context.moveTo(Math.random() * width, Math.random() * height);
                    context.lineTo(Math.random() * width, Math.random() * height);
                    context.stroke();
                }
            }
        });
    </script>
</body>

</html>